name: QuantumRoute V5 - Ultimate Intelligence

on:
  schedule:
    - cron: '0 */3 * * *'
  push:
    branches: ["main"]
  workflow_dispatch:

concurrency:
  group: quantum-v5
  cancel-in-progress: true

env:
  OUTPUT_DIR: output
  TIMEOUT_MS: 6000
  MAX_PARALLEL: 30
  MIN_SCORE: 400
  STABILITY_ATTEMPTS: 5
  ENABLE_ML: true
  ENABLE_HONEYPOT_DETECTION: true

jobs:
  quantum-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 150

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ğŸ“¦ Install All Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl netcat-openbsd openssl dnsutils whois
          npm init -y
          npm install p-limit node-fetch@2 geoip-lite

      - name: ğŸ“ Create Directory Structure
        run: |
          mkdir -p "$OUTPUT_DIR" tmp logs cache history
          
          # Load previous results for ML
          if [[ -f output/history.json ]]; then
            cp output/history.json cache/history.json
          fi
          
          echo "âœ… Directories created"

      - name: ğŸŒ Fetch Configs from All Sources
        run: |
          set -uo pipefail
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸŒ QuantumRoute V5 - Ultimate Intelligence Fetcher"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          SOURCES=(
            "https://ghproxy.net/https://raw.githubusercontent.com/barry-far/V2ray-Configs/refs/heads/main/All_Configs_Sub.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/85la/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/cfmeme/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/datiya/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/jichangx/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/nodefree/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/oneclash/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/yudou/v2ray.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/roosterkid/openproxylist/refs/heads/main/V2RAY_RAW.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/roosterkid/openproxylist/refs/heads/main/V2RAY_BASE64.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/refs/heads/main/all_extracted_configs.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/miladtahanian/V2RayCFGDumper/refs/heads/main/config.txt"
            "https://openproxylist.com/v2ray/rawlist/text"
            "https://openproxylist.com/v2ray/rawlist/subscribe"
            "https://ghproxy.net/https://raw.githubusercontent.com/ShatakVPN/ConfigForge-V2Ray/refs/heads/main/configs/all.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/Epodonios/v2ray-configs/refs/heads/main/All_Configs_Sub.txt"
            "https://ghproxy.net/https://raw.githubusercontent.com/itsyebekhe/PSG/main/subscriptions/xray/base64/mix"
          )
          
          for i in $(seq 6 38); do
            SOURCES+=("https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-${i}.txt")
          done
          
          : > tmp/raw_all.txt
          : > logs/fetch.log
          
          fetch_source() {
            local url="$1"
            local idx="$2"
            local outfile="tmp/src_${idx}.txt"
            
            if curl -fsSL --retry 3 --retry-delay 2 --connect-timeout 20 --max-time 60 \
              -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "$url" -o "$outfile" 2>/dev/null; then
              
              if file "$outfile" | grep -q "ASCII" && head -1 "$outfile" | grep -qE '^[A-Za-z0-9+/=]{20,}$'; then
                base64 -d "$outfile" 2>/dev/null > "${outfile}.dec" && mv "${outfile}.dec" "$outfile"
              fi
              
              local count=$(wc -l < "$outfile" 2>/dev/null || echo 0)
              echo "âœ… [$idx] $count lines" >> logs/fetch.log
              cat "$outfile" >> tmp/raw_all.txt
            else
              echo "âŒ [$idx] FAILED" >> logs/fetch.log
            fi
          }
          
          idx=0
          pids=()
          for url in "${SOURCES[@]}"; do
            fetch_source "$url" "$idx" &
            pids+=($!)
            ((idx++))
            if (( ${#pids[@]} >= 15 )); then
              wait "${pids[0]}" 2>/dev/null || true
              pids=("${pids[@]:1}")
            fi
          done
          for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null || true; done
          
          echo "ğŸ“Š Total lines: $(wc -l < tmp/raw_all.txt)"

      - name: ğŸ” Parse & Deduplicate
        run: |
          set -uo pipefail
          
          grep -oE '(vmess|vless|trojan|ss|ssr|hysteria|hysteria2|tuic)://[^[:space:]"<>'"'"']+' tmp/raw_all.txt 2>/dev/null | \
            sed 's/[[:space:]]*$//' | sort -u > tmp/all_configs.txt || true
          
          declare -A SEEN
          : > tmp/unique.txt
          
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || ${#line} -lt 10 ]] && continue
            clean=$(echo "$line" | tr -d '\r\n' | sed 's/[[:space:]]//g')
            hash=$(echo -n "$clean" | sha256sum | cut -d' ' -f1)
            if [[ -z "${SEEN[$hash]:-}" ]]; then
              SEEN[$hash]=1
              echo "$clean" >> tmp/unique.txt
            fi
          done < tmp/all_configs.txt
          
          echo "ğŸ“Š Unique: ${#SEEN[@]} configs"

      - name: ğŸ§ª V5 Ultimate Intelligence Tester
        run: |
          cat << 'TESTER_V5' > tester.js
          const net = require('net');
          const tls = require('tls');
          const https = require('https');
          const http = require('http');
          const fs = require('fs');
          const dns = require('dns');
          const crypto = require('crypto');
          const pLimit = require('p-limit');
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // ØªÙ†Ø¸ÛŒÙ…Ø§Øª V5
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const TIMEOUT = parseInt(process.env.TIMEOUT_MS) || 6000;
          const PARALLEL = parseInt(process.env.MAX_PARALLEL) || 30;
          const MIN_SCORE = parseInt(process.env.MIN_SCORE) || 400;
          const STABILITY_ATTEMPTS = parseInt(process.env.STABILITY_ATTEMPTS) || 5;
          const ENABLE_ML = process.env.ENABLE_ML === 'true';
          const ENABLE_HONEYPOT = process.env.ENABLE_HONEYPOT_DETECTION === 'true';
          
          const limit = pLimit(PARALLEL);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CDN Ranges
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const CDN_RANGES = {
            cloudflare: ['103.21.244.', '103.22.200.', '103.31.4.', '104.16.', '104.17.',
              '104.18.', '104.19.', '104.20.', '104.21.', '104.22.', '104.23.', '104.24.',
              '104.25.', '104.26.', '104.27.', '108.162.', '131.0.72.', '141.101.', '162.158.',
              '172.64.', '172.65.', '172.66.', '172.67.', '173.245.', '188.114.', '190.93.',
              '197.234.', '198.41.'],
            fastly: ['151.101.', '199.232.'],
            akamai: ['23.', '104.64.', '104.65.', '104.66.', '104.67.'],
            gcore: ['92.223.', '199.34.'],
            amazon: ['13.', '52.', '54.', '99.']
          };
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Honeypot Signatures
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const HONEYPOT_SIGNATURES = {
            // Ø³Ø±ÙˆØ±Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ù‡Ù…ÛŒØ´Ù‡ OK Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯ÙˆÙ†Ù† (Ù…Ø´Ú©ÙˆÚ©)
            suspiciousPatterns: [
              /^10\.\d+\.\d+\.\d+$/,        // Private IP
              /^192\.168\.\d+\.\d+$/,       // Private IP
              /^172\.(1[6-9]|2\d|3[01])\./,  // Private IP
              /localhost/i,
              /\.local$/i,
              /\.internal$/i
            ],
            
            // Ù¾ÙˆØ±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø´Ú©ÙˆÚ©
            suspiciousPorts: [22, 23, 25, 53, 110, 143, 3389],
            
            // Response patterns Ú©Ù‡ Ù†Ø´ÙˆÙ†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ honeypot Ù‡Ø³ØªÙ†
            honeypotResponses: [
              'honeypot',
              'tarpit',
              'trap',
              'blocked',
              'forbidden',
              'access denied'
            ]
          };
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Known Bad Patterns (DPI Triggers for Iran)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const DPI_RISK_PATTERNS = {
            // High risk SNIs
            highRiskSNI: [
              /google\./i,
              /youtube\./i,
              /facebook\./i,
              /twitter\./i,
              /instagram\./i,
              /telegram\./i
            ],
            
            // Safe SNIs for Iran
            safeSNI: [
              /cloudflare/i,
              /fastly/i,
              /akamai/i,
              /azure/i,
              /amazonaws/i
            ]
          };
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Scoring Weights
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const TRANSPORT_SCORES = {
            'ws': 150, 'grpc': 130, 'h2': 120, 'httpupgrade': 100,
            'splithttp': 90, 'tcp': 40, 'kcp': 30, 'quic': 80
          };
          
          const PROTOCOL_SCORES = {
            'vless': 120, 'trojan': 110, 'hysteria2': 100, 'hysteria': 90,
            'tuic': 85, 'vmess': 70, 'ss': 50, 'ssr': 40
          };
          
          const SECURITY_SCORES = {
            'reality': 200, 'tls': 120, 'none': -80
          };
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // ML History (Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          let mlHistory = { hosts: {}, patterns: {} };
          
          try {
            if (fs.existsSync('cache/history.json')) {
              mlHistory = JSON.parse(fs.readFileSync('cache/history.json', 'utf8'));
              console.log(`ğŸ“š Loaded ML history: ${Object.keys(mlHistory.hosts).length} hosts`);
            }
          } catch (e) {
            console.log('ğŸ“ Starting fresh ML history');
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const configs = fs.readFileSync('tmp/unique.txt', 'utf8')
            .trim().split('\n').filter(Boolean);
          
          console.log(`\n${'â•'.repeat(70)}`);
          console.log(`ğŸš€ QuantumRoute V5 - Ultimate Intelligence Engine`);
          console.log(`${'â•'.repeat(70)}`);
          console.log(`ğŸ“„ Configs: ${configs.length}`);
          console.log(`ğŸ§  ML Enabled: ${ENABLE_ML}`);
          console.log(`ğŸ´â€â˜ ï¸ Honeypot Detection: ${ENABLE_HONEYPOT}`);
          console.log(`${'â•'.repeat(70)}\n`);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          function extractHostPort(config) {
            try {
              const protocol = config.split('://')[0];
              
              if (protocol === 'vmess') {
                try {
                  const b64 = config.slice(8).split('#')[0];
                  const decoded = Buffer.from(b64, 'base64').toString('utf8');
                  const json = JSON.parse(decoded);
                  return {
                    protocol: 'vmess',
                    host: json.add || json.host || json.address,
                    port: parseInt(json.port) || 443,
                    security: json.tls === 'tls' ? 'tls' : 'none',
                    network: json.net || json.network || 'tcp',
                    sni: json.sni || json.host || '',
                    path: json.path || '',
                    alpn: json.alpn || ''
                  };
                } catch { return null; }
              }
              
              const match = config.match(/@([^:/?#]+):(\d+)/);
              if (match) {
                const urlPart = config.split('?')[1]?.split('#')[0] || '';
                const params = Object.fromEntries(new URLSearchParams(urlPart));
                
                return {
                  protocol,
                  host: match[1],
                  port: parseInt(match[2]),
                  security: params.security || (parseInt(match[2]) === 443 ? 'tls' : 'none'),
                  network: params.type || params.net || 'tcp',
                  sni: params.sni || params.host || match[1],
                  path: params.path || '',
                  alpn: params.alpn || '',
                  flow: params.flow || '',
                  fp: params.fp || ''
                };
              }
              
              if (protocol === 'ss') {
                const parts = config.slice(5).split('@');
                if (parts.length >= 2) {
                  const hp = parts[parts.length - 1].split('#')[0].split('?')[0].split(':');
                  return {
                    protocol: 'ss', host: hp[0], port: parseInt(hp[1]) || 443,
                    security: 'none', network: 'tcp', sni: ''
                  };
                }
              }
              return null;
            } catch { return null; }
          }
          
          function detectCDN(ip) {
            if (!ip) return null;
            for (const [cdn, ranges] of Object.entries(CDN_RANGES)) {
              if (ranges.some(range => ip.startsWith(range))) return cdn;
            }
            return null;
          }
          
          function resolveHost(host) {
            return new Promise((resolve) => {
              if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) {
                resolve({ ip: host, dns_time: 0 });
                return;
              }
              const start = Date.now();
              dns.resolve4(host, (err, addresses) => {
                resolve({
                  ip: addresses?.[0] || null,
                  dns_time: Date.now() - start,
                  error: err?.code
                });
              });
            });
          }
          
          function generateConfigHash(config) {
            return crypto.createHash('md5').update(config).digest('hex').slice(0, 12);
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Honeypot Detection
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function detectHoneypot(info, ip) {
            const flags = [];
            let score = 0;
            
            // Private IP check
            if (HONEYPOT_SIGNATURES.suspiciousPatterns.some(p => p.test(info.host))) {
              flags.push('private_ip');
              score += 100;
            }
            
            // Suspicious port
            if (HONEYPOT_SIGNATURES.suspiciousPorts.includes(info.port)) {
              flags.push('suspicious_port');
              score += 50;
            }
            
            // Same IP as host (no CDN/proxy)
            if (ip === info.host && !detectCDN(ip)) {
              flags.push('direct_ip');
              score += 20;
            }
            
            // High risk SNI
            if (DPI_RISK_PATTERNS.highRiskSNI.some(p => p.test(info.sni || info.host))) {
              flags.push('high_risk_sni');
              score += 80;
            }
            
            return {
              isHoneypot: score >= 100,
              isPossibleHoneypot: score >= 50,
              score,
              flags
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // DPI Fingerprint Simulation
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function analyzeDPIRisk(info, tlsResult) {
            let risk = 0;
            const factors = [];
            
            // SNI Analysis
            if (!info.sni || info.sni === info.host) {
              risk += 10;
              factors.push('no_sni_masking');
            }
            
            // TLS Version
            if (tlsResult?.version === 'TLSv1.2') {
              risk += 5;
              factors.push('old_tls');
            }
            
            // No ALPN
            if (!tlsResult?.alpn) {
              risk += 15;
              factors.push('no_alpn');
            }
            
            // High risk SNI patterns
            if (DPI_RISK_PATTERNS.highRiskSNI.some(p => p.test(info.sni || ''))) {
              risk += 40;
              factors.push('blocked_sni');
            }
            
            // Safe CDN SNI bonus
            if (DPI_RISK_PATTERNS.safeSNI.some(p => p.test(info.sni || ''))) {
              risk -= 20;
              factors.push('safe_sni');
            }
            
            // Reality check
            if (info.security === 'reality') {
              risk -= 30;
              factors.push('reality_protected');
            }
            
            // WebSocket with path
            if (info.network === 'ws' && info.path) {
              risk -= 10;
              factors.push('ws_with_path');
            }
            
            return {
              risk: Math.max(0, risk),
              level: risk > 50 ? 'high' : risk > 25 ? 'medium' : 'low',
              factors
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // TCP Test
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function testTCP(host, port, timeout = TIMEOUT) {
            return new Promise((resolve) => {
              const start = Date.now();
              const socket = net.createConnection({ host, port });
              socket.setTimeout(timeout);
              
              socket.on('connect', () => {
                const latency = Date.now() - start;
                socket.destroy();
                resolve({ ok: true, latency });
              });
              
              socket.on('error', (err) => {
                socket.destroy();
                resolve({ ok: false, latency: 9999, error: err.code });
              });
              
              socket.on('timeout', () => {
                socket.destroy();
                resolve({ ok: false, latency: 9999, error: 'TIMEOUT' });
              });
            });
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // TLS Test Ø¨Ø§ Fingerprint Ú©Ø§Ù…Ù„
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function testTLSAdvanced(host, port, sni, timeout = TIMEOUT) {
            return new Promise((resolve) => {
              const start = Date.now();
              
              try {
                const socket = tls.connect({
                  host, port,
                  servername: sni || host,
                  rejectUnauthorized: false,
                  timeout,
                  minVersion: 'TLSv1.2',
                  maxVersion: 'TLSv1.3',
                  // ALPN negotiation
                  ALPNProtocols: ['h2', 'http/1.1']
                });
                
                socket.setTimeout(timeout);
                
                socket.on('secureConnect', () => {
                  const latency = Date.now() - start;
                  const cert = socket.getPeerCertificate();
                  const tlsVersion = socket.getProtocol();
                  const cipher = socket.getCipher();
                  const alpn = socket.alpnProtocol;
                  
                  // JA3-like fingerprint (simplified)
                  const fingerprint = {
                    version: tlsVersion,
                    cipher: cipher?.name,
                    alpn,
                    extensions: []
                  };
                  
                  let certInfo = null;
                  if (cert && Object.keys(cert).length > 0) {
                    certInfo = {
                      issuer: cert.issuer?.O || cert.issuer?.CN,
                      subject: cert.subject?.CN,
                      valid: cert.valid_to ? new Date(cert.valid_to) > new Date() : false,
                      selfSigned: cert.issuer?.CN === cert.subject?.CN,
                      fingerprint: cert.fingerprint256?.slice(0, 20)
                    };
                  }
                  
                  socket.destroy();
                  
                  resolve({
                    ok: true,
                    latency,
                    version: tlsVersion,
                    cipher: cipher?.name,
                    alpn,
                    cert: certInfo,
                    fingerprint,
                    isModernTLS: tlsVersion === 'TLSv1.3',
                    hasALPN: !!alpn,
                    hasH2: alpn === 'h2'
                  });
                });
                
                socket.on('error', (err) => {
                  socket.destroy();
                  resolve({ ok: false, error: err.code, latency: Date.now() - start });
                });
                
                socket.on('timeout', () => {
                  socket.destroy();
                  resolve({ ok: false, error: 'TLS_TIMEOUT', latency: Date.now() - start });
                });
              } catch (e) {
                resolve({ ok: false, error: e.message });
              }
            });
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // HTTP GET Ø¨Ø§ Payload Integrity Check
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function testHTTPPayload(host, port, useTLS, path = '/', timeout = TIMEOUT) {
            return new Promise((resolve) => {
              const start = Date.now();
              let dataReceived = 0;
              let firstByteTime = null;
              let chunks = [];
              
              const options = {
                hostname: host, port, path,
                method: 'GET',
                timeout,
                headers: {
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0',
                  'Accept': 'text/html,*/*',
                  'Accept-Encoding': 'identity',
                  'Connection': 'close'
                },
                rejectUnauthorized: false
              };
              
              const protocol = useTLS ? https : http;
              
              try {
                const req = protocol.request(options, (res) => {
                  res.on('data', (chunk) => {
                    if (!firstByteTime) firstByteTime = Date.now() - start;
                    dataReceived += chunk.length;
                    if (chunks.length < 5) chunks.push(chunk);
                  });
                  
                  res.on('end', () => {
                    const totalTime = Date.now() - start;
                    const body = Buffer.concat(chunks).toString().slice(0, 500);
                    
                    // Honeypot response detection
                    const isHoneypotResponse = HONEYPOT_SIGNATURES.honeypotResponses
                      .some(p => body.toLowerCase().includes(p));
                    
                    // Integrity checks
                    const contentLength = parseInt(res.headers['content-length']) || 0;
                    const integrityOK = contentLength === 0 || Math.abs(dataReceived - contentLength) < 100;
                    
                    resolve({
                      ok: true,
                      latency: totalTime,
                      ttfb: firstByteTime,  // Time to First Byte
                      status: res.statusCode,
                      bodySize: dataReceived,
                      contentLength,
                      integrityOK,
                      headers: {
                        server: res.headers['server'],
                        cfRay: res.headers['cf-ray'],
                        via: res.headers['via'],
                        xCache: res.headers['x-cache']
                      },
                      isCloudflare: !!res.headers['cf-ray'],
                      isHoneypotResponse,
                      bodyPreview: body.slice(0, 100)
                    });
                  });
                });
                
                req.on('error', (err) => {
                  resolve({ ok: false, error: err.code, latency: Date.now() - start });
                });
                
                req.on('timeout', () => {
                  req.destroy();
                  resolve({ ok: false, error: 'HTTP_TIMEOUT', latency: Date.now() - start });
                });
                
                req.end();
              } catch (e) {
                resolve({ ok: false, error: e.message });
              }
            });
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Early Reset Detection
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function testEarlyReset(host, port, timeout = TIMEOUT) {
            return new Promise((resolve) => {
              const start = Date.now();
              let connected = false;
              let dataReceived = false;
              let resetTime = null;
              
              const socket = net.createConnection({ host, port });
              socket.setTimeout(timeout);
              
              socket.on('connect', () => {
                connected = true;
                // Ø§Ø±Ø³Ø§Ù„ HTTP request Ø³Ø§Ø¯Ù‡
                socket.write('GET / HTTP/1.1\r\nHost: ' + host + '\r\n\r\n');
              });
              
              socket.on('data', () => {
                dataReceived = true;
              });
              
              socket.on('close', (hadError) => {
                resetTime = Date.now() - start;
                socket.destroy();
                
                // Ø§Ú¯Ø± Ø¨Ø¹Ø¯ Ø§Ø² connect Ø³Ø±ÛŒØ¹ close Ø´Ø¯ = Ù…Ø´Ú©ÙˆÚ©
                const earlyReset = connected && !dataReceived && resetTime < 1000;
                
                resolve({
                  connected,
                  dataReceived,
                  resetTime,
                  earlyReset,
                  hadError
                });
              });
              
              socket.on('error', () => {
                socket.destroy();
                resolve({ connected, dataReceived, earlyReset: false, error: true });
              });
              
              socket.on('timeout', () => {
                socket.destroy();
                resolve({ connected, dataReceived, earlyReset: false, timeout: true });
              });
            });
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Multi-Attempt Stability Ø¨Ø§ Retry Analysis
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          async function testStabilityAdvanced(host, port, attempts = STABILITY_ATTEMPTS) {
            const results = [];
            const latencies = [];
            let consecutiveFailures = 0;
            let maxConsecutiveFailures = 0;
            
            for (let i = 0; i < attempts; i++) {
              const tcp = await testTCP(host, port, TIMEOUT / 2);
              
              results.push({
                attempt: i + 1,
                ok: tcp.ok,
                latency: tcp.latency,
                error: tcp.error
              });
              
              if (tcp.ok && tcp.latency < 9999) {
                latencies.push(tcp.latency);
                consecutiveFailures = 0;
              } else {
                consecutiveFailures++;
                maxConsecutiveFailures = Math.max(maxConsecutiveFailures, consecutiveFailures);
              }
              
              await new Promise(r => setTimeout(r, 400));
            }
            
            const successCount = results.filter(r => r.ok).length;
            const successRate = successCount / attempts;
            
            // Retry Pattern Analysis
            let getsWorseWithRetry = false;
            if (latencies.length >= 3) {
              const firstHalf = latencies.slice(0, Math.floor(latencies.length / 2));
              const secondHalf = latencies.slice(Math.floor(latencies.length / 2));
              const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
              const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
              getsWorseWithRetry = secondAvg > firstAvg * 1.5;
            }
            
            // Jitter calculation
            let jitter = 0, avgLatency = 0, minLatency = 9999, maxLatency = 0;
            if (latencies.length > 0) {
              avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;
              minLatency = Math.min(...latencies);
              maxLatency = Math.max(...latencies);
              const variance = latencies.reduce((a, b) => a + Math.pow(b - avgLatency, 2), 0) / latencies.length;
              jitter = Math.sqrt(variance);
            }
            
            return {
              attempts,
              successCount,
              successRate,
              avgLatency: Math.round(avgLatency),
              minLatency,
              maxLatency,
              jitter: Math.round(jitter),
              maxConsecutiveFailures,
              getsWorseWithRetry,
              stable: successRate >= 0.8 && jitter < 150 && !getsWorseWithRetry,
              veryStable: successRate >= 0.95 && jitter < 80,
              unreliable: successRate < 0.5 || maxConsecutiveFailures >= 3,
              results
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Fake SNI / Fallback Domain Test
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          async function testSNIBehavior(host, port, originalSNI) {
            const testSNIs = [
              originalSNI || host,           // Original
              'www.google.com',              // Known blocked
              'cloudflare.com',              // Safe
              'microsoft.com',               // Safe
              ''                             // Empty SNI
            ];
            
            const results = {};
            
            for (const sni of testSNIs) {
              if (!sni && sni !== '') continue;
              
              const tls = await testTLSAdvanced(host, port, sni, 3000);
              results[sni || 'empty'] = {
                ok: tls.ok,
                latency: tls.latency,
                error: tls.error
              };
              
              await new Promise(r => setTimeout(r, 200));
            }
            
            // Analysis
            const originalWorks = results[originalSNI || host]?.ok;
            const googleBlocked = !results['www.google.com']?.ok;
            const cloudflareWorks = results['cloudflare.com']?.ok;
            
            return {
              results,
              sniFiltering: googleBlocked && cloudflareWorks,
              originalWorks,
              recommendation: googleBlocked && cloudflareWorks ? 'use_safe_sni' : 'any_sni'
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Fake Congestion Detection
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          async function detectCongestion(host, port) {
            const samples = [];
            
            for (let i = 0; i < 4; i++) {
              const start = Date.now();
              const tcp = await testTCP(host, port, 2000);
              samples.push({
                latency: tcp.latency,
                ok: tcp.ok
              });
              await new Promise(r => setTimeout(r, 500));
            }
            
            const validSamples = samples.filter(s => s.ok).map(s => s.latency);
            if (validSamples.length < 2) return { congested: false, insufficient: true };
            
            const avg = validSamples.reduce((a, b) => a + b, 0) / validSamples.length;
            const increasing = validSamples.every((v, i) => i === 0 || v >= validSamples[i - 1] * 0.9);
            const highVariance = Math.max(...validSamples) > Math.min(...validSamples) * 2;
            
            return {
              congested: increasing && highVariance,
              throttled: avg > 500 && increasing,
              samples: validSamples,
              avgLatency: Math.round(avg)
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Cross-Protocol Sanity Check
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function validateProtocolConfig(info, httpResult) {
            const issues = [];
            
            // WebSocket Ø¨Ø§ÛŒØ¯ path Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡
            if (info.network === 'ws' && !info.path) {
              issues.push('ws_no_path');
            }
            
            // gRPC Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¨Ø§ÛŒØ¯ TLS Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡
            if (info.network === 'grpc' && info.security === 'none') {
              issues.push('grpc_no_tls');
            }
            
            // Reality Ø¨Ø§ÛŒØ¯ VLESS Ø¨Ø§Ø´Ù‡
            if (info.security === 'reality' && info.protocol !== 'vless') {
              issues.push('reality_wrong_protocol');
            }
            
            // Port 80 Ø¨Ø§ TLS?
            if (info.port === 80 && info.security === 'tls') {
              issues.push('tls_on_80');
            }
            
            // HTTP response Ø¨Ø±Ø±Ø³ÛŒ
            if (httpResult?.ok) {
              // Ø§Ú¯Ø± HTTP 4xx/5xx Ø¨Ø±Ú¯Ø±Ø¯ÙˆÙ†Ù‡ ÙˆÙ„ÛŒ Ø§Ø¯Ø¹Ø§ÛŒ proxy Ø¯Ø§Ø±Ù‡
              if (httpResult.status >= 400 && httpResult.status !== 400) {
                issues.push('http_error_response');
              }
            }
            
            return {
              valid: issues.length === 0,
              issues,
              severity: issues.length > 2 ? 'high' : issues.length > 0 ? 'medium' : 'none'
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // ML-Based Confidence Score
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function calculateMLConfidence(result, hostHistory) {
            let confidence = 50;  // Base confidence
            
            // Ø§Ú¯Ø± host Ù‚Ø¨Ù„Ø§Ù‹ ØªØ³Øª Ø´Ø¯Ù‡
            if (hostHistory) {
              const historicalSuccessRate = hostHistory.successes / (hostHistory.total || 1);
              confidence += (historicalSuccessRate - 0.5) * 40;
              
              // Ø§Ú¯Ø± Ø¨Ø§Ø±Ù‡Ø§ fail Ø´Ø¯Ù‡
              if (hostHistory.consecutiveFails >= 3) {
                confidence -= 30;
              }
            }
            
            // Current test results
            if (result.stability?.veryStable) confidence += 20;
            else if (result.stability?.stable) confidence += 10;
            else if (result.stability?.unreliable) confidence -= 25;
            
            if (result.cdn === 'cloudflare') confidence += 15;
            if (result.tls?.isModernTLS) confidence += 10;
            if (result.tls?.hasH2) confidence += 10;
            
            if (result.honeypot?.isHoneypot) confidence -= 50;
            if (result.dpiRisk?.level === 'high') confidence -= 20;
            
            if (result.earlyReset?.earlyReset) confidence -= 30;
            if (result.congestion?.throttled) confidence -= 15;
            
            if (result.http?.integrityOK === false) confidence -= 20;
            
            return Math.max(0, Math.min(100, Math.round(confidence)));
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Advanced Scoring Engine
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          function calculateV5Score(result) {
            let score = 500;
            const bonuses = [];
            const penalties = [];
            
            // â•â•â• TCP â•â•â•
            if (!result.tcp.ok) return { score: 0, reason: 'TCP_FAIL' };
            
            if (result.tcp.latency < 100) { score += 180; bonuses.push('ultra_low_latency'); }
            else if (result.tcp.latency < 200) { score += 120; bonuses.push('low_latency'); }
            else if (result.tcp.latency < 400) { score += 60; }
            else if (result.tcp.latency < 800) { score -= 30; }
            else { score -= 100; penalties.push('high_latency'); }
            
            // â•â•â• TLS â•â•â•
            if (result.tls) {
              if (result.tls.ok) {
                score += 100;
                bonuses.push('tls_ok');
                
                if (result.tls.isModernTLS) { score += 50; bonuses.push('tls13'); }
                if (result.tls.hasH2) { score += 60; bonuses.push('h2'); }
                if (result.tls.cert?.valid) { score += 30; bonuses.push('valid_cert'); }
                if (result.tls.cert?.selfSigned) { score -= 40; penalties.push('self_signed'); }
                
                if (result.tls.latency > 2000) { score -= 80; penalties.push('slow_tls'); }
              } else {
                score -= 150;
                penalties.push('tls_fail');
              }
            }
            
            // â•â•â• HTTP â•â•â•
            if (result.http) {
              if (result.http.ok) {
                score += 80;
                bonuses.push('http_ok');
                
                if (result.http.status === 200 || result.http.status === 204) { score += 30; }
                if (result.http.isCloudflare) { score += 50; bonuses.push('cf_verified'); }
                if (result.http.integrityOK) { score += 20; bonuses.push('integrity_ok'); }
                if (result.http.ttfb < 500) { score += 30; bonuses.push('fast_ttfb'); }
                if (result.http.isHoneypotResponse) { score -= 200; penalties.push('honeypot_response'); }
              } else {
                score -= 60;
                penalties.push('http_fail');
              }
            }
            
            // â•â•â• CDN â•â•â•
            const cdnScores = { cloudflare: 180, gcore: 140, fastly: 120, akamai: 100, amazon: 60 };
            if (result.cdn) {
              score += cdnScores[result.cdn] || 40;
              bonuses.push(`cdn_${result.cdn}`);
            }
            
            // â•â•â• Stability â•â•â•
            if (result.stability) {
              if (result.stability.veryStable) { score += 150; bonuses.push('very_stable'); }
              else if (result.stability.stable) { score += 80; bonuses.push('stable'); }
              else if (result.stability.unreliable) { score -= 120; penalties.push('unreliable'); }
              
              if (result.stability.jitter > 200) { score -= 80; penalties.push('high_jitter'); }
              if (result.stability.getsWorseWithRetry) { score -= 60; penalties.push('degrades_on_retry'); }
            }
            
            // â•â•â• Early Reset â•â•â•
            if (result.earlyReset?.earlyReset) {
              score -= 150;
              penalties.push('early_reset');
            }
            
            // â•â•â• Honeypot â•â•â•
            if (result.honeypot?.isHoneypot) {
              score -= 300;
              penalties.push('honeypot');
            } else if (result.honeypot?.isPossibleHoneypot) {
              score -= 100;
              penalties.push('possible_honeypot');
            }
            
            // â•â•â• DPI Risk â•â•â•
            if (result.dpiRisk) {
              if (result.dpiRisk.level === 'high') { score -= 100; penalties.push('high_dpi_risk'); }
              else if (result.dpiRisk.level === 'medium') { score -= 40; }
              else if (result.dpiRisk.level === 'low') { score += 30; bonuses.push('low_dpi_risk'); }
            }
            
            // â•â•â• Congestion â•â•â•
            if (result.congestion?.throttled) {
              score -= 80;
              penalties.push('throttled');
            }
            
            // â•â•â• Protocol Validation â•â•â•
            if (result.protocolValidation?.severity === 'high') {
              score -= 100;
              penalties.push('invalid_config');
            }
            
            // â•â•â• Protocol & Transport â•â•â•
            score += PROTOCOL_SCORES[result.protocol] || 0;
            score += TRANSPORT_SCORES[result.network] || 0;
            score += SECURITY_SCORES[result.security] || 0;
            
            // â•â•â• Special Combos â•â•â•
            if (result.security === 'reality' && result.protocol === 'vless') {
              score += 120;
              bonuses.push('reality_vless');
            }
            if (result.network === 'ws' && result.cdn === 'cloudflare') {
              score += 100;
              bonuses.push('ws_cf');
            }
            if (result.network === 'grpc' && result.tls?.isModernTLS) {
              score += 80;
              bonuses.push('grpc_tls13');
            }
            
            // â•â•â• ML Confidence â•â•â•
            if (result.confidence) {
              score += (result.confidence - 50) * 2;
            }
            
            return {
              score: Math.max(0, Math.round(score)),
              bonuses,
              penalties,
              grade: score >= 1000 ? 'S' : score >= 800 ? 'A' : score >= 600 ? 'B' : score >= 400 ? 'C' : 'D'
            };
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Main Test Function
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          async function testConfigV5(config, idx) {
            const info = extractHostPort(config);
            if (!info || !info.host || !info.port) {
              return { config, ok: false, reason: 'PARSE_ERROR' };
            }
            
            const { host, port, protocol, security, network, sni, path, flow, fp } = info;
            const needsTLS = security === 'tls' || security === 'reality' || port === 443;
            const configHash = generateConfigHash(config);
            
            // Get ML history for this host
            const hostHistory = mlHistory.hosts[host];
            
            // â•â•â• DNS â•â•â•
            const dnsResult = await resolveHost(host);
            if (!dnsResult.ip) {
              return { config, host, port, protocol, ok: false, reason: 'DNS_FAIL' };
            }
            
            const ip = dnsResult.ip;
            const cdn = detectCDN(ip);
            
            // â•â•â• Honeypot Check â•â•â•
            const honeypot = ENABLE_HONEYPOT ? detectHoneypot(info, ip) : null;
            if (honeypot?.isHoneypot) {
              return {
                config, host, port, protocol, ip, cdn,
                ok: false, reason: 'HONEYPOT',
                honeypot
              };
            }
            
            // â•â•â• TCP Test â•â•â•
            const tcp = await testTCP(host, port);
            if (!tcp.ok) {
              // Update ML history
              if (ENABLE_ML) {
                mlHistory.hosts[host] = mlHistory.hosts[host] || { total: 0, successes: 0, consecutiveFails: 0 };
                mlHistory.hosts[host].total++;
                mlHistory.hosts[host].consecutiveFails++;
              }
              return { config, host, port, protocol, ip, cdn, ok: false, reason: tcp.error, tcp };
            }
            
            // â•â•â• Early Reset Detection â•â•â•
            const earlyReset = await testEarlyReset(host, port);
            
            // â•â•â• TLS Test â•â•â•
            let tlsResult = null;
            if (needsTLS) {
              tlsResult = await testTLSAdvanced(host, port, sni);
            }
            
            // â•â•â• HTTP Payload Test â•â•â•
            let httpResult = null;
            if ((tlsResult?.ok || !needsTLS) && ![22, 3389].includes(port)) {
              httpResult = await testHTTPPayload(host, port, needsTLS, path || '/');
            }
            
            // â•â•â• Stability Test â•â•â•
            let stability = null;
            if (tcp.ok && tcp.latency < 1500) {
              stability = await testStabilityAdvanced(host, port);
            }
            
            // â•â•â• DPI Risk Analysis â•â•â•
            const dpiRisk = analyzeDPIRisk(info, tlsResult);
            
            // â•â•â• Congestion Detection â•â•â•
            let congestion = null;
            if (stability?.stable) {
              congestion = await detectCongestion(host, port);
            }
            
            // â•â•â• Protocol Validation â•â•â•
            const protocolValidation = validateProtocolConfig(info, httpResult);
            
            // â•â•â• Build Result â•â•â•
            const result = {
              config, configHash,
              host, port, ip,
              protocol, network, security,
              sni, path, flow, fp,
              cdn,
              tcp,
              tls: tlsResult,
              http: httpResult,
              stability,
              earlyReset,
              honeypot,
              dpiRisk,
              congestion,
              protocolValidation,
              dnsTime: dnsResult.dns_time
            };
            
            // â•â•â• ML Confidence â•â•â•
            result.confidence = ENABLE_ML ? calculateMLConfidence(result, hostHistory) : null;
            
            // â•â•â• Score â•â•â•
            const scoreResult = calculateV5Score(result);
            result.score = scoreResult.score;
            result.grade = scoreResult.grade;
            result.bonuses = scoreResult.bonuses;
            result.penalties = scoreResult.penalties;
            result.ok = result.score >= MIN_SCORE;
            
            // â•â•â• Update ML History â•â•â•
            if (ENABLE_ML) {
              mlHistory.hosts[host] = mlHistory.hosts[host] || { total: 0, successes: 0, consecutiveFails: 0 };
              mlHistory.hosts[host].total++;
              if (result.ok) {
                mlHistory.hosts[host].successes++;
                mlHistory.hosts[host].consecutiveFails = 0;
              } else {
                mlHistory.hosts[host].consecutiveFails++;
              }
            }
            
            // â•â•â• Progress â•â•â•
            if (idx % 80 === 0) {
              process.stdout.write(`\r   ğŸ“Š Progress: ${idx}/${configs.length} (${Math.round(idx/configs.length*100)}%)`);
            }
            
            return result;
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Main Execution
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          async function main() {
            const startTime = Date.now();
            
            console.log('ğŸ”¬ Starting V5 Ultimate Intelligence Tests...\n');
            
            const results = await Promise.all(
              configs.map((c, i) => limit(() => testConfigV5(c, i)))
            );
            
            console.log('\n\n');
            
            // â•â•â• Categorize Results â•â•â•
            const working = results.filter(r => r.ok && r.score >= MIN_SCORE).sort((a, b) => b.score - a.score);
            const failed = results.filter(r => !r.ok);
            
            const gradeS = working.filter(r => r.grade === 'S');
            const gradeA = working.filter(r => r.grade === 'A');
            const gradeB = working.filter(r => r.grade === 'B');
            const gradeC = working.filter(r => r.grade === 'C');
            
            const honeypots = results.filter(r => r.honeypot?.isHoneypot);
            const highDPIRisk = results.filter(r => r.dpiRisk?.level === 'high');
            
            // â•â•â• Save Files â•â•â•
            fs.writeFileSync('output/configs.txt', working.map(r => r.config).join('\n'));
            fs.writeFileSync('output/configs_base64.txt', 
              working.map(r => Buffer.from(r.config).toString('base64')).join('\n'));
            fs.writeFileSync('output/working.txt', working.map(r => r.config).join('\n'));
            fs.writeFileSync('output/best.txt', working.slice(0, 200).map(r => r.config).join('\n'));
            fs.writeFileSync('output/premium.txt', [...gradeS, ...gradeA].map(r => r.config).join('\n'));
            fs.writeFileSync('output/grade_s.txt', gradeS.map(r => r.config).join('\n'));
            fs.writeFileSync('output/top50.txt', working.slice(0, 50).map(r => r.config).join('\n'));
            
            // â•â•â• Stats â•â•â•
            const duration = Math.round((Date.now() - startTime) / 1000);
            
            const stats = {
              version: 'v5',
              timestamp: new Date().toISOString(),
              duration_sec: duration,
              
              summary: {
                total: configs.length,
                working: working.length,
                failed: failed.length,
                success_rate: ((working.length / configs.length) * 100).toFixed(2) + '%'
              },
              
              grades: {
                S: gradeS.length,
                A: gradeA.length,
                B: gradeB.length,
                C: gradeC.length
              },
              
              quality: {
                avg_score: working.length ? Math.round(working.reduce((a, b) => a + b.score, 0) / working.length) : 0,
                max_score: working.length ? Math.max(...working.map(r => r.score)) : 0,
                avg_latency: working.length ? Math.round(working.reduce((a, b) => a + b.tcp.latency, 0) / working.length) : 0,
                avg_confidence: working.filter(r => r.confidence).length ?
                  Math.round(working.filter(r => r.confidence).reduce((a, b) => a + b.confidence, 0) / working.filter(r => r.confidence).length) : 0
              },
              
              security: {
                honeypots_detected: honeypots.length,
                high_dpi_risk: highDPIRisk.length,
                cloudflare: working.filter(r => r.cdn === 'cloudflare').length,
                reality: working.filter(r => r.security === 'reality').length
              },
              
              stability: {
                very_stable: working.filter(r => r.stability?.veryStable).length,
                stable: working.filter(r => r.stability?.stable).length,
                unstable: working.filter(r => r.stability?.unreliable).length
              },
              
              protocols: {},
              networks: {},
              
              top_30: working.slice(0, 30).map(r => ({
                host: r.host,
                port: r.port,
                protocol: r.protocol,
                network: r.network,
                security: r.security,
                latency: r.tcp.latency,
                score: r.score,
                grade: r.grade,
                confidence: r.confidence,
                cdn: r.cdn,
                tls_version: r.tls?.version,
                stable: r.stability?.stable,
                dpi_risk: r.dpiRisk?.level,
                bonuses: r.bonuses?.slice(0, 5),
                penalties: r.penalties?.slice(0, 3)
              }))
            };
            
            // Protocol/Network distribution
            working.forEach(r => {
              stats.protocols[r.protocol] = (stats.protocols[r.protocol] || 0) + 1;
              stats.networks[r.network] = (stats.networks[r.network] || 0) + 1;
            });
            
            fs.writeFileSync('output/results.json', JSON.stringify(stats, null, 2));
            fs.writeFileSync('output/stats.json', JSON.stringify({
              total: configs.length,
              working: working.length,
              failed: failed.length,
              grade_s: gradeS.length,
              grade_a: gradeA.length,
              avg_score: stats.quality.avg_score,
              avg_latency: stats.quality.avg_latency,
              avg_confidence: stats.quality.avg_confidence,
              cloudflare: stats.security.cloudflare,
              honeypots: honeypots.length,
              updated: new Date().toISOString()
            }, null, 2));
            
            // â•â•â• ML History â•â•â•
            if (ENABLE_ML) {
              // Keep only hosts seen in last 7 days (simulate)
              const recentHosts = {};
              Object.entries(mlHistory.hosts).forEach(([host, data]) => {
                if (data.total > 0) recentHosts[host] = data;
              });
              mlHistory.hosts = recentHosts;
              
              fs.writeFileSync('output/history.json', JSON.stringify(mlHistory, null, 2));
            }
            
            // â•â•â• Prometheus Metrics â•â•â•
            const metrics = [
              `quantum_version 5`,
              `quantum_total ${configs.length}`,
              `quantum_working ${working.length}`,
              `quantum_grade_s ${gradeS.length}`,
              `quantum_grade_a ${gradeA.length}`,
              `quantum_avg_score ${stats.quality.avg_score}`,
              `quantum_avg_confidence ${stats.quality.avg_confidence}`,
              `quantum_honeypots ${honeypots.length}`,
              `quantum_cloudflare ${stats.security.cloudflare}`,
              ...working.slice(0, 100).map(r =>
                `quantum_score{host="${r.host}",protocol="${r.protocol}",grade="${r.grade}"} ${r.score}`
              )
            ].join('\n');
            
            fs.writeFileSync('output/metrics.prom', metrics);
            
            // â•â•â• Final Report â•â•â•
            console.log('â•'.repeat(70));
            console.log('ğŸ“Š QUANTUMROUTE V5 - FINAL RESULTS');
            console.log('â•'.repeat(70));
            console.log(`   â±ï¸  Duration:        ${duration}s`);
            console.log(`   ğŸ“„ Total:           ${configs.length}`);
            console.log(`   âœ… Working:         ${working.length} (${((working.length/configs.length)*100).toFixed(1)}%)`);
            console.log('');
            console.log('   ğŸ“Š Grade Distribution:');
            console.log(`      ğŸ† S (1000+):    ${gradeS.length}`);
            console.log(`      ğŸ¥‡ A (800-999):  ${gradeA.length}`);
            console.log(`      ğŸ¥ˆ B (600-799):  ${gradeB.length}`);
            console.log(`      ğŸ¥‰ C (400-599):  ${gradeC.length}`);
            console.log('');
            console.log('   ğŸ”’ Security:');
            console.log(`      ğŸ´â€â˜ ï¸ Honeypots:    ${honeypots.length}`);
            console.log(`      âš ï¸  High DPI Risk: ${highDPIRisk.length}`);
            console.log(`      â˜ï¸  Cloudflare:   ${stats.security.cloudflare}`);
            console.log(`      ğŸ” Reality:      ${stats.security.reality}`);
            console.log('');
            console.log(`   âš¡ Avg Latency:     ${stats.quality.avg_latency}ms`);
            console.log(`   ğŸ† Avg Score:       ${stats.quality.avg_score}`);
            console.log(`   ğŸ§  Avg Confidence:  ${stats.quality.avg_confidence}%`);
            console.log('â•'.repeat(70));
          }
          
          main().catch(err => {
            console.error('âŒ Fatal:', err);
            process.exit(1);
          });
          TESTER_V5
          
          node tester.js

      - name: ğŸ“Š Generate V5 Dashboard
        run: |
          cat << 'DASHBOARD_V5' > output/index.html
          <!DOCTYPE html>
          <html lang="fa" dir="rtl">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>QuantumRoute V5 - Ultimate Intelligence</title>
            <style>
              :root {
                --bg-primary: #080b10;
                --bg-secondary: #0f1419;
                --bg-card: #161d27;
                --bg-hover: #1e2836;
                --border: #2a3544;
                --text-primary: #e7edf4;
                --text-secondary: #8899aa;
                --accent-gold: #ffd700;
                --accent-blue: #3b82f6;
                --accent-green: #10b981;
                --accent-red: #ef4444;
                --accent-purple: #8b5cf6;
                --accent-cyan: #06b6d4;
                --accent-orange: #f97316;
              }
              * { box-sizing: border-box; margin: 0; padding: 0; }
              body {
                font-family: 'Segoe UI', system-ui, sans-serif;
                background: var(--bg-primary);
                color: var(--text-primary);
                min-height: 100vh;
              }
              .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
              
              header {
                text-align: center;
                padding: 60px 20px;
                background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
                border-bottom: 1px solid var(--border);
              }
              .logo {
                font-size: 3.5rem;
                font-weight: 900;
                background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange), var(--accent-red));
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
              }
              .version {
                display: inline-block;
                background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
                padding: 6px 16px;
                border-radius: 20px;
                font-size: 0.9rem;
                font-weight: 600;
                margin: 15px 0;
              }
              .tagline { color: var(--text-secondary); font-size: 1.2rem; }
              
              .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
                margin: 30px 0;
              }
              .stat {
                background: var(--bg-card);
                border: 1px solid var(--border);
                border-radius: 16px;
                padding: 20px;
                text-align: center;
                transition: all 0.3s;
              }
              .stat:hover { transform: translateY(-5px); border-color: var(--accent-blue); }
              .stat-icon { font-size: 2rem; margin-bottom: 8px; }
              .stat-value { font-size: 2rem; font-weight: 800; }
              .stat-label { color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px; }
              
              .grade-section {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 15px;
                margin: 30px 0;
              }
              .grade-card {
                background: var(--bg-card);
                border-radius: 16px;
                padding: 25px;
                text-align: center;
                border: 2px solid transparent;
                transition: all 0.3s;
              }
              .grade-card:hover { transform: scale(1.02); }
              .grade-card.s { border-color: var(--accent-gold); }
              .grade-card.a { border-color: var(--accent-green); }
              .grade-card.b { border-color: var(--accent-blue); }
              .grade-card.c { border-color: var(--accent-purple); }
              .grade-letter { font-size: 3rem; font-weight: 900; }
              .grade-count { font-size: 2rem; font-weight: 700; margin-top: 10px; }
              .grade-label { color: var(--text-secondary); }
              
              .security-alerts {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin: 30px 0;
              }
              .alert {
                background: var(--bg-card);
                border-radius: 12px;
                padding: 20px;
                display: flex;
                align-items: center;
                gap: 15px;
              }
              .alert-icon { font-size: 2rem; }
              .alert-info { flex: 1; }
              .alert-value { font-size: 1.5rem; font-weight: 700; }
              .alert-label { color: var(--text-secondary); font-size: 0.85rem; }
              
              .actions {
                display: flex;
                gap: 12px;
                justify-content: center;
                flex-wrap: wrap;
                margin: 30px 0;
              }
              .btn {
                padding: 14px 28px;
                border-radius: 12px;
                font-weight: 600;
                text-decoration: none;
                transition: all 0.3s;
                display: inline-flex;
                align-items: center;
                gap: 8px;
              }
              .btn-gold { background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange)); color: #000; }
              .btn-primary { background: var(--accent-green); color: #fff; }
              .btn-secondary { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border); }
              .btn:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
              
              .section-title {
                font-size: 1.5rem;
                margin: 40px 0 20px;
                padding-bottom: 15px;
                border-bottom: 2px solid var(--border);
                display: flex;
                align-items: center;
                gap: 12px;
              }
              
              .table-container {
                background: var(--bg-card);
                border-radius: 16px;
                overflow: hidden;
                border: 1px solid var(--border);
              }
              table { width: 100%; border-collapse: collapse; }
              th, td { padding: 14px 12px; text-align: right; border-bottom: 1px solid var(--border); }
              th { background: var(--bg-secondary); font-weight: 600; color: var(--accent-blue); position: sticky; top: 0; }
              tr:hover { background: var(--bg-hover); }
              
              .grade-badge {
                display: inline-block;
                padding: 4px 12px;
                border-radius: 8px;
                font-weight: 700;
                font-size: 0.9rem;
              }
              .grade-badge.s { background: rgba(255,215,0,0.2); color: var(--accent-gold); }
              .grade-badge.a { background: rgba(16,185,129,0.2); color: var(--accent-green); }
              .grade-badge.b { background: rgba(59,130,246,0.2); color: var(--accent-blue); }
              .grade-badge.c { background: rgba(139,92,246,0.2); color: var(--accent-purple); }
              
              .protocol-tag {
                padding: 4px 10px;
                border-radius: 6px;
                font-size: 0.75rem;
                font-weight: 700;
                text-transform: uppercase;
              }
              .protocol-vless { background: #8b5cf6; color: #fff; }
              .protocol-vmess { background: #3b82f6; color: #fff; }
              .protocol-trojan { background: #ef4444; color: #fff; }
              .protocol-ss { background: #22c55e; color: #fff; }
              
              .confidence-bar {
                width: 60px;
                height: 8px;
                background: var(--bg-secondary);
                border-radius: 4px;
                overflow: hidden;
                display: inline-block;
                vertical-align: middle;
              }
              .confidence-fill {
                height: 100%;
                border-radius: 4px;
              }
              
              .risk-badge {
                padding: 3px 8px;
                border-radius: 4px;
                font-size: 0.7rem;
                font-weight: 600;
              }
              .risk-low { background: rgba(16,185,129,0.2); color: var(--accent-green); }
              .risk-medium { background: rgba(251,191,36,0.2); color: var(--accent-orange); }
              .risk-high { background: rgba(239,68,68,0.2); color: var(--accent-red); }
              
              footer {
                text-align: center;
                padding: 40px;
                color: var(--text-secondary);
                border-top: 1px solid var(--border);
                margin-top: 50px;
              }
              
              @media (max-width: 768px) {
                .logo { font-size: 2.5rem; }
                .grade-section { grid-template-columns: repeat(2, 1fr); }
                th, td { padding: 10px 6px; font-size: 0.8rem; }
              }
            </style>
          </head>
          <body>
            <header>
              <div class="logo">ğŸš€ QuantumRoute</div>
              <span class="version">V5 Ultimate Intelligence</span>
              <p class="tagline">Ù‡ÙˆØ´Ù…Ù†Ø¯ØªØ±ÛŒÙ† Ø³ÛŒØ³ØªÙ… ØªØ³Øª Ú©Ø§Ù†ÙÛŒÚ¯ V2Ray Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ±Ø§Ù†</p>
            </header>
            
            <div class="container">
              <div class="stats-grid" id="stats"></div>
              
              <div class="grade-section">
                <div class="grade-card s">
                  <div class="grade-letter" style="color: var(--accent-gold)">S</div>
                  <div class="grade-count" id="grade-s">-</div>
                  <div class="grade-label">Premium (1000+)</div>
                </div>
                <div class="grade-card a">
                  <div class="grade-letter" style="color: var(--accent-green)">A</div>
                  <div class="grade-count" id="grade-a">-</div>
                  <div class="grade-label">Excellent (800-999)</div>
                </div>
                <div class="grade-card b">
                  <div class="grade-letter" style="color: var(--accent-blue)">B</div>
                  <div class="grade-count" id="grade-b">-</div>
                  <div class="grade-label">Good (600-799)</div>
                </div>
                <div class="grade-card c">
                  <div class="grade-letter" style="color: var(--accent-purple)">C</div>
                  <div class="grade-count" id="grade-c">-</div>
                  <div class="grade-label">Acceptable (400-599)</div>
                </div>
              </div>
              
              <div class="security-alerts" id="security"></div>
              
              <div class="actions">
                <a href="grade_s.txt" class="btn btn-gold">ğŸ† Grade S Configs</a>
                <a href="premium.txt" class="btn btn-primary">â­ Premium (S+A)</a>
                <a href="best.txt" class="btn btn-secondary">ğŸ“¥ Top 200</a>
                <a href="configs.txt" class="btn btn-secondary">ğŸ“„ All Working</a>
                <a href="configs_base64.txt" class="btn btn-secondary">ğŸ” Base64</a>
                <a href="results.json" class="btn btn-secondary">ğŸ“Š JSON</a>
              </div>
              
              <h2 class="section-title">ğŸ† Top 30 Configs</h2>
              <div class="table-container">
                <table>
                  <thead>
                    <tr>
                      <th>#</th>
                      <th>Grade</th>
                      <th>Protocol</th>
                      <th>Host</th>
                      <th>Latency</th>
                      <th>Score</th>
                      <th>Confidence</th>
                      <th>DPI Risk</th>
                      <th>CDN</th>
                    </tr>
                  </thead>
                  <tbody id="results"></tbody>
                </table>
              </div>
            </div>
            
            <footer>
              <p>Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: <span id="timestamp">-</span></p>
              <p>QuantumRoute V5 - Ultimate Intelligence Engine</p>
            </footer>
            
            <script>
              async function load() {
                const data = await fetch('results.json').then(r => r.json());
                
                // Stats
                const statsHtml = `
                  <div class="stat">
                    <div class="stat-icon">ğŸ“„</div>
                    <div class="stat-value" style="color: var(--accent-blue)">${data.summary.total}</div>
                    <div class="stat-label">Ú©Ù„ ØªØ³Øª Ø´Ø¯Ù‡</div>
                  </div>
                  <div class="stat">
                    <div class="stat-icon">âœ…</div>
                    <div class="stat-value" style="color: var(--accent-green)">${data.summary.working}</div>
                    <div class="stat-label">Ø³Ø§Ù„Ù…</div>
                  </div>
                  <div class="stat">
                    <div class="stat-icon">âš¡</div>
                    <div class="stat-value" style="color: var(--accent-orange)">${data.quality.avg_latency}ms</div>
                    <div class="stat-label">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ØªØ§Ø®ÛŒØ±</div>
                  </div>
                  <div class="stat">
                    <div class="stat-icon">ğŸ†</div>
                    <div class="stat-value" style="color: var(--accent-gold)">${data.quality.avg_score}</div>
                    <div class="stat-label">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø²</div>
                  </div>
                  <div class="stat">
                    <div class="stat-icon">ğŸ§ </div>
                    <div class="stat-value" style="color: var(--accent-cyan)">${data.quality.avg_confidence}%</div>
                    <div class="stat-label">Ø§Ø·Ù…ÛŒÙ†Ø§Ù† ML</div>
                  </div>
                  <div class="stat">
                    <div class="stat-icon">â˜ï¸</div>
                    <div class="stat-value" style="color: var(--accent-blue)">${data.security.cloudflare}</div>
                    <div class="stat-label">Cloudflare</div>
                  </div>
                `;
                document.getElementById('stats').innerHTML = statsHtml;
                
                // Grades
                document.getElementById('grade-s').textContent = data.grades.S;
                document.getElementById('grade-a').textContent = data.grades.A;
                document.getElementById('grade-b').textContent = data.grades.B;
                document.getElementById('grade-c').textContent = data.grades.C;
                
                // Security
                const securityHtml = `
                  <div class="alert">
                    <div class="alert-icon">ğŸ´â€â˜ ï¸</div>
                    <div class="alert-info">
                      <div class="alert-value" style="color: var(--accent-red)">${data.security.honeypots_detected}</div>
                      <div class="alert-label">Honeypots Detected</div>
                    </div>
                  </div>
                  <div class="alert">
                    <div class="alert-icon">âš ï¸</div>
                    <div class="alert-info">
                      <div class="alert-value" style="color: var(--accent-orange)">${data.security.high_dpi_risk}</div>
                      <div class="alert-label">High DPI Risk</div>
                    </div>
                  </div>
                  <div class="alert">
                    <div class="alert-icon">ğŸ”</div>
                    <div class="alert-info">
                      <div class="alert-value" style="color: var(--accent-green)">${data.security.reality}</div>
                      <div class="alert-label">Reality Protected</div>
                    </div>
                  </div>
                  <div class="alert">
                    <div class="alert-icon">ğŸ”’</div>
                    <div class="alert-info">
                      <div class="alert-value" style="color: var(--accent-blue)">${data.stability.very_stable}</div>
                      <div class="alert-label">Very Stable</div>
                    </div>
                  </div>
                `;
                document.getElementById('security').innerHTML = securityHtml;
                
                // Table
                const tbody = document.getElementById('results');
                data.top_30.forEach((r, i) => {
                  const gradeClass = r.grade.toLowerCase();
                  const riskClass = r.dpi_risk === 'high' ? 'high' : r.dpi_risk === 'medium' ? 'medium' : 'low';
                  const confColor = r.confidence >= 70 ? 'var(--accent-green)' : r.confidence >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';
                  
                  tbody.innerHTML += `
                    <tr>
                      <td>${i + 1}</td>
                      <td><span class="grade-badge ${gradeClass}">${r.grade}</span></td>
                      <td><span class="protocol-tag protocol-${r.protocol}">${r.protocol}</span></td>
                      <td>${r.host}</td>
                      <td>${r.latency}ms</td>
                      <td><strong>${r.score}</strong></td>
                      <td>
                        <span class="confidence-bar">
                          <span class="confidence-fill" style="width: ${r.confidence}%; background: ${confColor}"></span>
                        </span>
                        ${r.confidence}%
                      </td>
                      <td><span class="risk-badge risk-${riskClass}">${r.dpi_risk || 'low'}</span></td>
                      <td>${r.cdn || '-'}</td>
                    </tr>
                  `;
                });
                
                document.getElementById('timestamp').textContent = new Date(data.timestamp).toLocaleString('fa-IR');
              }
              load();
            </script>
          </body>
          </html>
          DASHBOARD_V5

      - name: ğŸ’¾ Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add output/
          
          if [[ -f output/stats.json ]]; then
            W=$(jq -r '.working' output/stats.json)
            S=$(jq -r '.grade_s' output/stats.json)
            A=$(jq -r '.grade_a' output/stats.json)
            SCORE=$(jq -r '.avg_score' output/stats.json)
            git commit -m "ğŸš€ V5: ${W} working | S:${S} A:${A} | avg:${SCORE}" || true
          else
            git commit -m "ğŸš€ V5 Update" || true
          fi
          git push || true

      - name: ğŸ“¦ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: quantum-v5-output
          path: output/
          retention-days: 14
