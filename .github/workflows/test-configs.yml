name: QuantumRoute V5 - Ultimate Intelligence

on:
  schedule:
    - cron: '0 */3 * * *'
  push:
    branches: ["main"]
  workflow_dispatch:

concurrency:
  group: quantum-v5
  cancel-in-progress: true

env:
  OUTPUT_DIR: output
  TIMEOUT_MS: 6000
  MAX_PARALLEL: 30
  MIN_SCORE: 400
  STABILITY_ATTEMPTS: 5
  ENABLE_ML: "true"
  ENABLE_HONEYPOT_DETECTION: "true"

jobs:
  quantum-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 150

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ğŸ“¦ Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl netcat-openbsd openssl dnsutils file
          npm init -y
          npm install p-limit node-fetch@2 geoip-lite

      - name: ğŸ“ Create Directories
        run: |
          mkdir -p output tmp logs cache history
          touch tmp/raw_all.txt logs/fetch.log
          echo "âœ… Ready"

      - name: ğŸŒ Fetch All Configs
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸŒ QuantumRoute V5 - Fetching Configs"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Ù„ÛŒØ³Øª URL Ù‡Ø§
          cat > tmp/urls.txt << 'URLS'
          https://ghproxy.net/https://raw.githubusercontent.com/barry-far/V2ray-Configs/refs/heads/main/All_Configs_Sub.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/85la/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/cfmeme/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/datiya/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/jichangx/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/nodefree/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/oneclash/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/yudou/v2ray.txt
          https://ghproxy.net/https://raw.githubusercontent.com/roosterkid/openproxylist/refs/heads/main/V2RAY_RAW.txt
          https://ghproxy.net/https://raw.githubusercontent.com/roosterkid/openproxylist/refs/heads/main/V2RAY_BASE64.txt
          https://ghproxy.net/https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/refs/heads/main/all_extracted_configs.txt
          https://ghproxy.net/https://raw.githubusercontent.com/miladtahanian/V2RayCFGDumper/refs/heads/main/config.txt
          https://openproxylist.com/v2ray/rawlist/text
          https://openproxylist.com/v2ray/rawlist/subscribe
          https://ghproxy.net/https://raw.githubusercontent.com/ShatakVPN/ConfigForge-V2Ray/refs/heads/main/configs/all.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Epodonios/v2ray-configs/refs/heads/main/All_Configs_Sub.txt
          https://ghproxy.net/https://raw.githubusercontent.com/itsyebekhe/PSG/main/subscriptions/xray/base64/mix
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-6.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-7.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-8.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-9.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-10.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-11.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-12.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-13.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-14.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-15.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-16.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-17.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-18.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-19.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-20.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-21.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-22.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-23.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-24.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-25.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-26.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-27.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-28.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-29.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-30.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-31.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-32.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-33.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-34.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-35.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-36.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-37.txt
          https://ghproxy.net/https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-38.txt
          URLS
          
          echo "ğŸ“‹ Sources: $(wc -l < tmp/urls.txt)"
          echo ""
          
          # Fetch ÛŒÚ©ÛŒ ÛŒÚ©ÛŒ (Ù…Ø·Ù…Ø¦Ù†â€ŒØªØ±)
          idx=0
          success=0
          failed=0
          
          while IFS= read -r url || [[ -n "$url" ]]; do
            [[ -z "$url" ]] && continue
            
            outfile="tmp/src_${idx}.txt"
            
            if curl -fsSL --retry 2 --connect-timeout 15 --max-time 45 \
              -H "User-Agent: Mozilla/5.0" \
              "$url" -o "$outfile" 2>/dev/null; then
              
              # Ø¨Ø±Ø±Ø³ÛŒ Base64
              if [[ -s "$outfile" ]]; then
                firstline=$(head -c 100 "$outfile" 2>/dev/null | tr -d '\n\r')
                if [[ "$firstline" =~ ^[A-Za-z0-9+/=]{20,}$ ]]; then
                  base64 -d "$outfile" > "${outfile}.dec" 2>/dev/null && mv "${outfile}.dec" "$outfile" 2>/dev/null
                fi
              fi
              
              if [[ -s "$outfile" ]]; then
                lines=$(wc -l < "$outfile" 2>/dev/null || echo 0)
                cat "$outfile" >> tmp/raw_all.txt 2>/dev/null
                echo "âœ… [$idx] $lines lines" >> logs/fetch.log
                ((success++))
              fi
            else
              echo "âŒ [$idx] failed" >> logs/fetch.log
              ((failed++))
            fi
            
            ((idx++))
            
            # Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ´Ø±ÙØª Ù‡Ø± 10 ØªØ§
            if (( idx % 10 == 0 )); then
              echo "   Progress: $idx sources processed..."
            fi
            
          done < tmp/urls.txt
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š Fetch Complete: âœ… $success success | âŒ $failed failed"
          echo "ğŸ“„ Total lines: $(wc -l < tmp/raw_all.txt 2>/dev/null || echo 0)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: ğŸ” Parse & Deduplicate
        run: |
          echo "ğŸ” Parsing configs..."
          
          # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ±ÙˆØ¯ÛŒ
          if [[ ! -s tmp/raw_all.txt ]]; then
            echo "âš ï¸ No raw data, creating empty output"
            touch tmp/unique.txt
            exit 0
          fi
          
          # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§
          grep -oE '(vmess|vless|trojan|ss|ssr|hysteria|hysteria2|tuic)://[^[:space:]"<>'"'"']+' tmp/raw_all.txt 2>/dev/null | \
            sed 's/[[:space:]]*$//' | \
            sort -u > tmp/all_configs.txt || touch tmp/all_configs.txt
          
          echo "ğŸ“„ Extracted: $(wc -l < tmp/all_configs.txt) configs"
          
          # Deduplication
          awk '!seen[$0]++' tmp/all_configs.txt > tmp/unique.txt 2>/dev/null || cp tmp/all_configs.txt tmp/unique.txt
          
          echo "ğŸ”· Unique: $(wc -l < tmp/unique.txt) configs"

      - name: ğŸ§ª V5 Tester
        run: |
          if [[ ! -s tmp/unique.txt ]]; then
            echo "âš ï¸ No configs to test"
            mkdir -p output
            echo "" > output/configs.txt
            echo "" > output/configs_base64.txt
            echo '{"summary":{"total":0,"working":0,"failed":0},"grades":{"S":0,"A":0,"B":0,"C":0},"quality":{"avg_score":0,"avg_latency":0,"avg_confidence":0},"security":{"honeypots_detected":0,"cloudflare":0},"top_30":[]}' > output/results.json
            echo '{"total":0,"working":0,"grade_s":0,"grade_a":0}' > output/stats.json
            exit 0
          fi
          
          node << 'NODEJS'
          const net = require('net');
          const tls = require('tls');
          const https = require('https');
          const http = require('http');
          const fs = require('fs');
          const dns = require('dns');
          const crypto = require('crypto');
          
          // ØªÙ†Ø¸ÛŒÙ…Ø§Øª
          const TIMEOUT = 6000;
          const PARALLEL = 30;
          const MIN_SCORE = 400;
          const STABILITY_ATTEMPTS = 4;
          
          // CDN
          const CDN_RANGES = {
            cloudflare: ['103.21.244.', '103.22.200.', '103.31.4.', '104.16.', '104.17.', '104.18.', '104.19.', '104.20.', '104.21.', '104.22.', '104.23.', '104.24.', '104.25.', '104.26.', '104.27.', '108.162.', '131.0.72.', '141.101.', '162.158.', '172.64.', '172.65.', '172.66.', '172.67.', '173.245.', '188.114.', '190.93.', '197.234.', '198.41.'],
            fastly: ['151.101.', '199.232.'],
            gcore: ['92.223.', '199.34.']
          };
          
          // Scoring
          const TRANSPORT_SCORES = { ws: 150, grpc: 130, h2: 120, tcp: 40 };
          const PROTOCOL_SCORES = { vless: 120, trojan: 110, hysteria2: 100, vmess: 70, ss: 50 };
          const SECURITY_SCORES = { reality: 200, tls: 120, none: -80 };
          
          // ML History
          let mlHistory = { hosts: {} };
          try {
            if (fs.existsSync('cache/history.json')) {
              mlHistory = JSON.parse(fs.readFileSync('cache/history.json', 'utf8'));
            }
          } catch (e) {}
          
          // Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§
          let configs = [];
          try {
            configs = fs.readFileSync('tmp/unique.txt', 'utf8').trim().split('\n').filter(Boolean);
          } catch (e) {
            console.log('No configs');
            process.exit(0);
          }
          
          console.log(`\n${'â•'.repeat(60)}`);
          console.log(`ğŸš€ QuantumRoute V5 - Testing ${configs.length} configs`);
          console.log(`${'â•'.repeat(60)}\n`);
          
          // ØªÙˆØ§Ø¨Ø¹
          function extractHostPort(config) {
            try {
              const protocol = config.split('://')[0];
              
              if (protocol === 'vmess') {
                const b64 = config.slice(8).split('#')[0];
                const json = JSON.parse(Buffer.from(b64, 'base64').toString('utf8'));
                return {
                  protocol: 'vmess',
                  host: json.add || json.host,
                  port: parseInt(json.port) || 443,
                  security: json.tls === 'tls' ? 'tls' : 'none',
                  network: json.net || 'tcp',
                  sni: json.sni || json.host || ''
                };
              }
              
              const match = config.match(/@([^:/?#]+):(\d+)/);
              if (match) {
                const params = Object.fromEntries(new URLSearchParams(config.split('?')[1]?.split('#')[0] || ''));
                return {
                  protocol,
                  host: match[1],
                  port: parseInt(match[2]),
                  security: params.security || (parseInt(match[2]) === 443 ? 'tls' : 'none'),
                  network: params.type || 'tcp',
                  sni: params.sni || match[1]
                };
              }
              
              if (protocol === 'ss') {
                const parts = config.slice(5).split('@');
                if (parts.length >= 2) {
                  const hp = parts[parts.length - 1].split('#')[0].split('?')[0].split(':');
                  return { protocol: 'ss', host: hp[0], port: parseInt(hp[1]) || 443, security: 'none', network: 'tcp', sni: '' };
                }
              }
              return null;
            } catch (e) { return null; }
          }
          
          function detectCDN(ip) {
            if (!ip) return null;
            for (const [cdn, ranges] of Object.entries(CDN_RANGES)) {
              if (ranges.some(r => ip.startsWith(r))) return cdn;
            }
            return null;
          }
          
          function resolveHost(host) {
            return new Promise(resolve => {
              if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) return resolve({ ip: host, time: 0 });
              const start = Date.now();
              dns.resolve4(host, (err, addr) => resolve({ ip: addr?.[0], time: Date.now() - start, error: err?.code }));
            });
          }
          
          function testTCP(host, port) {
            return new Promise(resolve => {
              const start = Date.now();
              const socket = net.createConnection({ host, port });
              socket.setTimeout(TIMEOUT);
              socket.on('connect', () => { socket.destroy(); resolve({ ok: true, latency: Date.now() - start }); });
              socket.on('error', e => { socket.destroy(); resolve({ ok: false, latency: 9999, error: e.code }); });
              socket.on('timeout', () => { socket.destroy(); resolve({ ok: false, latency: 9999, error: 'TIMEOUT' }); });
            });
          }
          
          function testTLS(host, port, sni) {
            return new Promise(resolve => {
              const start = Date.now();
              try {
                const socket = tls.connect({
                  host, port, servername: sni || host,
                  rejectUnauthorized: false, timeout: TIMEOUT,
                  ALPNProtocols: ['h2', 'http/1.1']
                });
                socket.setTimeout(TIMEOUT);
                socket.on('secureConnect', () => {
                  const cert = socket.getPeerCertificate();
                  const version = socket.getProtocol();
                  const alpn = socket.alpnProtocol;
                  socket.destroy();
                  resolve({
                    ok: true, latency: Date.now() - start, version, alpn,
                    cert: cert ? { valid: cert.valid_to ? new Date(cert.valid_to) > new Date() : false } : null,
                    isModernTLS: version === 'TLSv1.3', hasH2: alpn === 'h2'
                  });
                });
                socket.on('error', e => { socket.destroy(); resolve({ ok: false, error: e.code }); });
                socket.on('timeout', () => { socket.destroy(); resolve({ ok: false, error: 'TIMEOUT' }); });
              } catch (e) { resolve({ ok: false, error: e.message }); }
            });
          }
          
          function testHTTP(host, port, useTLS) {
            return new Promise(resolve => {
              const start = Date.now();
              const proto = useTLS ? https : http;
              try {
                const req = proto.request({
                  hostname: host, port, path: '/', method: 'HEAD', timeout: TIMEOUT,
                  headers: { 'User-Agent': 'Mozilla/5.0', Connection: 'close' },
                  rejectUnauthorized: false
                }, res => {
                  resolve({
                    ok: true, latency: Date.now() - start, status: res.statusCode,
                    isCloudflare: !!res.headers['cf-ray']
                  });
                });
                req.on('error', () => resolve({ ok: false }));
                req.on('timeout', () => { req.destroy(); resolve({ ok: false }); });
                req.end();
              } catch (e) { resolve({ ok: false }); }
            });
          }
          
          async function testStability(host, port) {
            const latencies = [];
            for (let i = 0; i < STABILITY_ATTEMPTS; i++) {
              const r = await testTCP(host, port);
              if (r.ok && r.latency < 9999) latencies.push(r.latency);
              await new Promise(r => setTimeout(r, 200));
            }
            if (latencies.length === 0) return { stable: false, veryStable: false, jitter: 9999 };
            const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;
            const jitter = Math.sqrt(latencies.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / latencies.length);
            const rate = latencies.length / STABILITY_ATTEMPTS;
            return { stable: rate >= 0.75 && jitter < 150, veryStable: rate >= 0.9 && jitter < 80, jitter: Math.round(jitter), avgLatency: Math.round(avg) };
          }
          
          function detectHoneypot(info) {
            if (/^(10\.|192\.168\.|172\.(1[6-9]|2\d|3[01])\.)/.test(info.host)) return { isHoneypot: true };
            if ([22, 23, 25].includes(info.port)) return { isHoneypot: true };
            return { isHoneypot: false };
          }
          
          function calcDPIRisk(info, tls) {
            let risk = 0;
            if (!info.sni) risk += 10;
            if (!tls?.alpn) risk += 15;
            if (info.security === 'reality') risk -= 30;
            if (info.network === 'ws') risk -= 10;
            return { risk: Math.max(0, risk), level: risk > 40 ? 'high' : risk > 20 ? 'medium' : 'low' };
          }
          
          function calcScore(r) {
            let score = 500;
            const bonuses = [], penalties = [];
            
            if (!r.tcp.ok) return { score: 0, grade: 'F', bonuses, penalties };
            
            if (r.tcp.latency < 100) { score += 180; bonuses.push('ultra_fast'); }
            else if (r.tcp.latency < 200) { score += 120; bonuses.push('fast'); }
            else if (r.tcp.latency < 400) score += 60;
            else if (r.tcp.latency > 800) { score -= 100; penalties.push('slow'); }
            
            if (r.tls?.ok) {
              score += 100; bonuses.push('tls_ok');
              if (r.tls.isModernTLS) { score += 50; bonuses.push('tls13'); }
              if (r.tls.hasH2) { score += 60; bonuses.push('h2'); }
              if (r.tls.cert?.valid) score += 30;
            } else if (r.needsTLS) { score -= 150; penalties.push('tls_fail'); }
            
            if (r.http?.ok) { score += 80; if (r.http.isCloudflare) { score += 50; bonuses.push('cf'); } }
            
            const cdnScores = { cloudflare: 180, gcore: 140, fastly: 120 };
            if (r.cdn) { score += cdnScores[r.cdn] || 40; bonuses.push('cdn'); }
            
            if (r.stability?.veryStable) { score += 150; bonuses.push('very_stable'); }
            else if (r.stability?.stable) { score += 80; bonuses.push('stable'); }
            else if (r.stability?.jitter > 200) { score -= 80; penalties.push('jitter'); }
            
            if (r.honeypot?.isHoneypot) { score -= 300; penalties.push('honeypot'); }
            if (r.dpiRisk?.level === 'high') { score -= 100; penalties.push('dpi_risk'); }
            
            score += PROTOCOL_SCORES[r.protocol] || 0;
            score += TRANSPORT_SCORES[r.network] || 0;
            score += SECURITY_SCORES[r.security] || 0;
            
            if (r.security === 'reality' && r.protocol === 'vless') { score += 120; bonuses.push('reality_vless'); }
            if (r.network === 'ws' && r.cdn === 'cloudflare') { score += 100; bonuses.push('ws_cf'); }
            
            const finalScore = Math.max(0, Math.round(score));
            const grade = finalScore >= 1000 ? 'S' : finalScore >= 800 ? 'A' : finalScore >= 600 ? 'B' : finalScore >= 400 ? 'C' : 'D';
            return { score: finalScore, grade, bonuses, penalties };
          }
          
          async function testConfig(config, idx) {
            const info = extractHostPort(config);
            if (!info) return { config, ok: false, reason: 'PARSE_ERROR' };
            
            const { host, port, protocol, security, network, sni } = info;
            const needsTLS = security === 'tls' || security === 'reality' || port === 443;
            
            const honeypot = detectHoneypot(info);
            if (honeypot.isHoneypot) return { config, host, port, protocol, ok: false, reason: 'HONEYPOT', honeypot };
            
            const dns = await resolveHost(host);
            if (!dns.ip) return { config, host, port, protocol, ok: false, reason: 'DNS_FAIL' };
            
            const cdn = detectCDN(dns.ip);
            const tcp = await testTCP(host, port);
            if (!tcp.ok) {
              mlHistory.hosts[host] = mlHistory.hosts[host] || { total: 0, fails: 0 };
              mlHistory.hosts[host].total++;
              mlHistory.hosts[host].fails++;
              return { config, host, port, protocol, cdn, ok: false, reason: tcp.error, tcp };
            }
            
            let tlsResult = null;
            if (needsTLS) tlsResult = await testTLS(host, port, sni);
            
            let httpResult = null;
            if (tlsResult?.ok || !needsTLS) httpResult = await testHTTP(host, port, needsTLS);
            
            let stability = null;
            if (tcp.latency < 1500) stability = await testStability(host, port);
            
            const dpiRisk = calcDPIRisk(info, tlsResult);
            
            const result = {
              config, host, port, ip: dns.ip, protocol, network, security, sni, cdn, needsTLS,
              tcp, tls: tlsResult, http: httpResult, stability, honeypot, dpiRisk
            };
            
            const scoreResult = calcScore(result);
            Object.assign(result, scoreResult);
            result.ok = result.score >= MIN_SCORE;
            
            mlHistory.hosts[host] = mlHistory.hosts[host] || { total: 0, fails: 0 };
            mlHistory.hosts[host].total++;
            if (!result.ok) mlHistory.hosts[host].fails++;
            
            if (idx % 100 === 0) process.stdout.write(`\r   Progress: ${idx}/${configs.length}`);
            
            return result;
          }
          
          // Simple parallel limiter
          async function runWithLimit(items, limit, fn) {
            const results = [];
            let idx = 0;
            
            async function worker() {
              while (idx < items.length) {
                const i = idx++;
                results[i] = await fn(items[i], i);
              }
            }
            
            await Promise.all(Array(Math.min(limit, items.length)).fill(null).map(worker));
            return results;
          }
          
          async function main() {
            const startTime = Date.now();
            
            const results = await runWithLimit(configs, PARALLEL, testConfig);
            
            console.log('\n\n');
            
            const working = results.filter(r => r.ok).sort((a, b) => b.score - a.score);
            const failed = results.filter(r => !r.ok);
            
            const gradeS = working.filter(r => r.grade === 'S');
            const gradeA = working.filter(r => r.grade === 'A');
            const gradeB = working.filter(r => r.grade === 'B');
            const gradeC = working.filter(r => r.grade === 'C');
            
            // Save files
            fs.writeFileSync('output/configs.txt', working.map(r => r.config).join('\n'));
            fs.writeFileSync('output/configs_base64.txt', working.map(r => Buffer.from(r.config).toString('base64')).join('\n'));
            fs.writeFileSync('output/working.txt', working.map(r => r.config).join('\n'));
            fs.writeFileSync('output/best.txt', working.slice(0, 200).map(r => r.config).join('\n'));
            fs.writeFileSync('output/premium.txt', [...gradeS, ...gradeA].map(r => r.config).join('\n'));
            fs.writeFileSync('output/grade_s.txt', gradeS.map(r => r.config).join('\n'));
            fs.writeFileSync('output/top50.txt', working.slice(0, 50).map(r => r.config).join('\n'));
            
            const duration = Math.round((Date.now() - startTime) / 1000);
            
            const protocols = {}, networks = {};
            working.forEach(r => {
              protocols[r.protocol] = (protocols[r.protocol] || 0) + 1;
              networks[r.network] = (networks[r.network] || 0) + 1;
            });
            
            const stats = {
              version: 'v5',
              timestamp: new Date().toISOString(),
              duration_sec: duration,
              summary: {
                total: configs.length,
                working: working.length,
                failed: failed.length,
                success_rate: ((working.length / configs.length) * 100).toFixed(2) + '%'
              },
              grades: { S: gradeS.length, A: gradeA.length, B: gradeB.length, C: gradeC.length },
              quality: {
                avg_score: working.length ? Math.round(working.reduce((a, b) => a + b.score, 0) / working.length) : 0,
                max_score: working.length ? Math.max(...working.map(r => r.score)) : 0,
                avg_latency: working.length ? Math.round(working.reduce((a, b) => a + b.tcp.latency, 0) / working.length) : 0,
                avg_confidence: 50
              },
              security: {
                honeypots_detected: results.filter(r => r.honeypot?.isHoneypot).length,
                high_dpi_risk: results.filter(r => r.dpiRisk?.level === 'high').length,
                cloudflare: working.filter(r => r.cdn === 'cloudflare').length,
                reality: working.filter(r => r.security === 'reality').length
              },
              stability: {
                very_stable: working.filter(r => r.stability?.veryStable).length,
                stable: working.filter(r => r.stability?.stable).length
              },
              protocols,
              networks,
              top_30: working.slice(0, 30).map(r => ({
                host: r.host, port: r.port, protocol: r.protocol, network: r.network,
                security: r.security, latency: r.tcp.latency, score: r.score, grade: r.grade,
                confidence: 50, cdn: r.cdn, tls_version: r.tls?.version,
                stable: r.stability?.stable, dpi_risk: r.dpiRisk?.level,
                bonuses: r.bonuses?.slice(0, 5), penalties: r.penalties?.slice(0, 3)
              }))
            };
            
            fs.writeFileSync('output/results.json', JSON.stringify(stats, null, 2));
            fs.writeFileSync('output/stats.json', JSON.stringify({
              total: configs.length, working: working.length, failed: failed.length,
              grade_s: gradeS.length, grade_a: gradeA.length,
              avg_score: stats.quality.avg_score, avg_latency: stats.quality.avg_latency,
              cloudflare: stats.security.cloudflare, updated: new Date().toISOString()
            }, null, 2));
            
            fs.writeFileSync('output/history.json', JSON.stringify(mlHistory, null, 2));
            
            const metrics = [
              'quantum_version 5',
              `quantum_total ${configs.length}`,
              `quantum_working ${working.length}`,
              `quantum_grade_s ${gradeS.length}`,
              `quantum_grade_a ${gradeA.length}`,
              `quantum_avg_score ${stats.quality.avg_score}`,
              ...working.slice(0, 50).map(r => `quantum_score{host="${r.host}",protocol="${r.protocol}"} ${r.score}`)
            ].join('\n');
            fs.writeFileSync('output/metrics.prom', metrics);
            
            console.log('â•'.repeat(60));
            console.log('ğŸ“Š QUANTUMROUTE V5 RESULTS');
            console.log('â•'.repeat(60));
            console.log(`   â±ï¸  Duration:    ${duration}s`);
            console.log(`   ğŸ“„ Total:       ${configs.length}`);
            console.log(`   âœ… Working:     ${working.length} (${((working.length/configs.length)*100).toFixed(1)}%)`);
            console.log(`   ğŸ† S: ${gradeS.length} | A: ${gradeA.length} | B: ${gradeB.length} | C: ${gradeC.length}`);
            console.log(`   âš¡ Avg Latency: ${stats.quality.avg_latency}ms`);
            console.log(`   â˜ï¸  Cloudflare: ${stats.security.cloudflare}`);
            console.log('â•'.repeat(60));
          }
          
          main().catch(e => {
            console.error('Error:', e.message);
            fs.writeFileSync('output/configs.txt', '');
            fs.writeFileSync('output/results.json', JSON.stringify({summary:{total:0,working:0}}));
            fs.writeFileSync('output/stats.json', JSON.stringify({total:0,working:0}));
          });
          NODEJS

      - name: ğŸ“Š Generate Dashboard
        run: |
          cat << 'EOF' > output/index.html
          <!DOCTYPE html>
          <html lang="fa" dir="rtl">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>QuantumRoute V5</title>
            <style>
              :root{--bg:#0a0e14;--card:#161d27;--border:#2a3544;--text:#e7edf4;--gold:#ffd700;--blue:#3b82f6;--green:#10b981;--red:#ef4444;--purple:#8b5cf6}
              *{box-sizing:border-box;margin:0;padding:0}body{font-family:system-ui,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;padding:20px}
              .container{max-width:1400px;margin:0 auto}h1{text-align:center;font-size:2.5rem;background:linear-gradient(135deg,var(--gold),var(--blue));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:30px}
              .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-bottom:25px}
              .stat{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:16px;text-align:center}
              .stat-value{font-size:1.8rem;font-weight:700}.stat-label{color:#8899aa;font-size:0.8rem;margin-top:4px}
              .grades{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:25px}
              .grade{background:var(--card);border-radius:10px;padding:16px;text-align:center;border:2px solid transparent}
              .grade.s{border-color:var(--gold)}.grade.a{border-color:var(--green)}.grade.b{border-color:var(--blue)}.grade.c{border-color:var(--purple)}
              .grade-letter{font-size:2rem;font-weight:900}.grade-count{font-size:1.3rem;font-weight:700;margin-top:8px}
              .actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-bottom:25px}
              .btn{padding:10px 20px;border-radius:8px;font-weight:600;text-decoration:none;font-size:0.9rem}
              .btn-gold{background:linear-gradient(135deg,var(--gold),#f97316);color:#000}.btn-green{background:var(--green);color:#fff}.btn-sec{background:var(--card);color:var(--text);border:1px solid var(--border)}
              table{width:100%;border-collapse:collapse;background:var(--card);border-radius:10px;overflow:hidden}
              th,td{padding:10px;text-align:right;border-bottom:1px solid var(--border);font-size:0.85rem}th{background:#0f1419;color:var(--blue)}tr:hover{background:#1e2836}
              .badge{display:inline-block;padding:3px 8px;border-radius:5px;font-size:0.75rem;font-weight:600}
              .badge-s{background:rgba(255,215,0,0.2);color:var(--gold)}.badge-a{background:rgba(16,185,129,0.2);color:var(--green)}.badge-b{background:rgba(59,130,246,0.2);color:var(--blue)}.badge-c{background:rgba(139,92,246,0.2);color:var(--purple)}
              footer{text-align:center;padding:20px;color:#8899aa;margin-top:30px;font-size:0.85rem}
              @media(max-width:600px){.grades{grid-template-columns:repeat(2,1fr)}.stats{grid-template-columns:repeat(2,1fr)}}
            </style>
          </head>
          <body>
            <div class="container">
              <h1>ğŸš€ QuantumRoute V5</h1>
              <div class="stats" id="stats"></div>
              <div class="grades">
                <div class="grade s"><div class="grade-letter" style="color:var(--gold)">S</div><div class="grade-count" id="gs">-</div></div>
                <div class="grade a"><div class="grade-letter" style="color:var(--green)">A</div><div class="grade-count" id="ga">-</div></div>
                <div class="grade b"><div class="grade-letter" style="color:var(--blue)">B</div><div class="grade-count" id="gb">-</div></div>
                <div class="grade c"><div class="grade-letter" style="color:var(--purple)">C</div><div class="grade-count" id="gc">-</div></div>
              </div>
              <div class="actions">
                <a href="grade_s.txt" class="btn btn-gold">ğŸ† S</a>
                <a href="premium.txt" class="btn btn-green">â­ Premium</a>
                <a href="configs.txt" class="btn btn-sec">ğŸ“¥ All</a>
                <a href="configs_base64.txt" class="btn btn-sec">ğŸ” B64</a>
                <a href="results.json" class="btn btn-sec">ğŸ“Š JSON</a>
              </div>
              <table><thead><tr><th>#</th><th>Grade</th><th>Protocol</th><th>Host</th><th>Latency</th><th>Score</th><th>CDN</th></tr></thead><tbody id="tb"></tbody></table>
            </div>
            <footer>Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: <span id="ts">-</span></footer>
            <script>
              fetch('results.json').then(r=>r.json()).then(d=>{
                document.getElementById('stats').innerHTML=`
                  <div class="stat"><div class="stat-value" style="color:var(--blue)">${d.summary.total}</div><div class="stat-label">Ú©Ù„</div></div>
                  <div class="stat"><div class="stat-value" style="color:var(--green)">${d.summary.working}</div><div class="stat-label">Ø³Ø§Ù„Ù…</div></div>
                  <div class="stat"><div class="stat-value" style="color:var(--gold)">${d.quality.avg_score}</div><div class="stat-label">Ø§Ù…ØªÛŒØ§Ø²</div></div>
                  <div class="stat"><div class="stat-value">${d.quality.avg_latency}ms</div><div class="stat-label">ØªØ§Ø®ÛŒØ±</div></div>
                  <div class="stat"><div class="stat-value" style="color:var(--blue)">${d.security.cloudflare}</div><div class="stat-label">CF</div></div>
                `;
                document.getElementById('gs').textContent=d.grades.S;
                document.getElementById('ga').textContent=d.grades.A;
                document.getElementById('gb').textContent=d.grades.B;
                document.getElementById('gc').textContent=d.grades.C;
                document.getElementById('ts').textContent=new Date(d.timestamp).toLocaleString('fa-IR');
                const tb=document.getElementById('tb');
                d.top_30.forEach((r,i)=>{
                  tb.innerHTML+=`<tr><td>${i+1}</td><td><span class="badge badge-${r.grade.toLowerCase()}">${r.grade}</span></td><td>${r.protocol}</td><td>${r.host}</td><td>${r.latency}ms</td><td>${r.score}</td><td>${r.cdn||'-'}</td></tr>`;
                });
              }).catch(()=>{});
            </script>
          </body>
          </html>
          EOF

      - name: ğŸ’¾ Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add output/ || true
          
          if [[ -f output/stats.json ]]; then
            W=$(jq -r '.working // 0' output/stats.json 2>/dev/null || echo 0)
            S=$(jq -r '.grade_s // 0' output/stats.json 2>/dev/null || echo 0)
            A=$(jq -r '.grade_a // 0' output/stats.json 2>/dev/null || echo 0)
            git commit -m "ğŸš€ V5: ${W} working | S:${S} A:${A}" || true
          else
            git commit -m "ğŸš€ V5 Update" || true
          fi
          
          git push || true

      - name: ğŸ“¦ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: quantum-v5
          path: output/
          retention-days: 14
