name: V2Ray Config Auto-Test & Filter

on:
  push:
    branches: ["main"]
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:

concurrency:
  group: v2ray-test
  cancel-in-progress: true

permissions:
  contents: write

env:
  OUTPUT_DIR: output
  TIMEOUT: 8
  MAX_PARALLEL: 30

jobs:
  fetch-test-filter:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq openssl curl netcat-traditional wget unzip
          npm install -g node-fetch@2 p-limit

      - name: Download and install Xray-core
        run: |
          echo "üì¶ Installing Xray-core for real protocol testing..."
          
          XRAY_VERSION=$(curl -s https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
          echo "  ‚Üí Version: ${XRAY_VERSION}"
          
          if [ -z "$XRAY_VERSION" ]; then
            echo "‚ùå Failed to get Xray version"
            exit 1
          fi
          
          DOWNLOAD_URL="https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-64.zip"
          echo "  ‚Üí Download URL: ${DOWNLOAD_URL}"
          
          wget --retry-connrefused --waitretry=1 --read-timeout=20 --timeout=15 --tries=3 "${DOWNLOAD_URL}" -O xray.zip
          
          if [ ! -f xray.zip ]; then
            echo "‚ùå Download failed"
            exit 1
          fi
          
          unzip -o xray.zip xray
          chmod +x xray
          sudo mv xray /usr/local/bin/
          
          xray version
          echo "‚úÖ Xray-core installed successfully"

      - name: Create directories
        run: |
          mkdir -p $OUTPUT_DIR tmp logs
          chmod 755 $OUTPUT_DIR tmp logs

      - name: Fetch configs from all sources
        run: |
          set -Eeuo pipefail
          
          echo "üåê Fetching configs from multiple sources..."
          
          SOURCES=(
            "https://raw.githubusercontent.com/barry-far/V2ray-Config/refs/heads/main/All_Configs_Sub.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/85la/v2ray.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/cfmeme/v2ray.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/datiya/v2ray.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/jichangx/v2ray.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/nodefree/v2ray.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/oneclash/v2ray.txt"
            "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/yudou/v2ray.txt"
            "https://raw.githubusercontent.com/roosterkid/openproxylist/refs/heads/main/V2RAY_RAW.txt"
            "https://raw.githubusercontent.com/roosterkid/openproxylist/refs/heads/main/V2RAY_BASE64.txt"
            "https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/refs/heads/main/all_extracted_configs.txt"
            "https://raw.githubusercontent.com/miladtahanian/V2RayCFGDumper/refs/heads/main/config.txt"
            "https://raw.githubusercontent.com/ShatakVPN/ConfigForge-V2Ray/refs/heads/main/configs/all.txt"
            "https://raw.githubusercontent.com/Epodonios/v2ray-configs/refs/heads/main/All_Configs_Sub.txt"
            "https://raw.githubusercontent.com/itsyebekhe/PSG/main/subscriptions/xray/base64/mix"
            "https://openproxylist.com/v2ray/rawlist/text"
            "https://openproxylist.com/v2ray/rawlist/subscribe"
          )
          
          for i in {1..38}; do
            SOURCES+=("https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-${i}.txt")
          done
          
          true > tmp/all_raw.txt
          
          fetch_source() {
            local url="$1"
            local idx="$2"
            local out="tmp/source_${idx}.txt"
            
            echo "  ‚Üí Fetching source ${idx}..."
            
            if curl -fsSL --retry 3 --connect-timeout 15 --max-time 30 --dns-servers 8.8.8.8,1.1.1.1 "$url" -o "$out" 2>/dev/null; then
              echo "    ‚úÖ Source ${idx} OK"
            else
              echo "    ‚ö†Ô∏è  Source ${idx} failed (non-fatal)"
              touch "$out"
            fi
          }
          
          for i in "${!SOURCES[@]}"; do
            fetch_source "${SOURCES[$i]}" "$i" &
            
            if (( (i + 1) % 20 == 0 )); then
              wait
            fi
          done
          wait
          
          cat tmp/source_*.txt 2>/dev/null | sed '/^$/d' > tmp/all_raw.txt || true
          
          echo "‚úÖ Fetching complete"

      - name: Parse and normalize configs
        run: |
          set -Eeuo pipefail
          
          echo "üîç Parsing and normalizing configs..."
          
          true > tmp/configs_parsed.txt
          
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "${line// }" ]] && continue
            
            if echo "$line" | grep -qE '^[A-Za-z0-9+/=]{20,}$' && ! echo "$line" | grep -q '://'; then
              decoded=$(echo "$line" | base64 -d 2>/dev/null || echo "")
              if [[ -n "$decoded" ]]; then
                echo "$decoded"
              fi
            else
              echo "$line"
            fi
          done < tmp/all_raw.txt | grep -E '^(vmess|vless|trojan|ss|trojan-go|hysteria|hysteria2|tuic)://' | tr -d '\r' > tmp/configs_parsed.txt || true
          
          echo "‚úÖ Parsed $(wc -l < tmp/configs_parsed.txt) total configs"

      - name: Smart deduplication
        run: |
          set -Eeuo pipefail
          
          echo "üßπ Deduplicating configs..."
          
          declare -A SEEN
          true > tmp/configs_unique.txt
          
          UNIQUE_COUNT=0
          
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" ]] && continue
            
            norm="$(echo "$line" | tr -d '\r\n[:space:]')"
            hash="$(echo -n "$norm" | sha256sum | cut -d' ' -f1)"
            
            if [[ ! -v "SEEN[$hash]" ]]; then
              SEEN[$hash]=1
              echo "$line" >> tmp/configs_unique.txt
              ((UNIQUE_COUNT++))
            fi
          done < tmp/configs_parsed.txt
          
          echo "‚úÖ Unique configs: $UNIQUE_COUNT"

      - name: Real connection test (Iran-optimized)
        run: |
          cat << 'EOTEST' > test.js
          const net = require('net');
          const tls = require('tls');
          const fs = require('fs');
          
          const TIMEOUT = parseInt(process.env.TIMEOUT || '8') * 1000;
          const MAX_PARALLEL = parseInt(process.env.MAX_PARALLEL || '30');
          
          const configs = fs.readFileSync('tmp/configs_unique.txt', 'utf8')
            .trim().split('\n').filter(Boolean);
          
          const results = {
            working: [],
            failed: []
          };
          
          function extractHost(configUrl) {
            try {
              const match = configUrl.match(/@([^:]+):(\d+)/);
              if (match) return { host: match[1], port: parseInt(match[2]) };
              
              const url = new URL(configUrl.replace(/^[^:]+:\/\//, 'http://'));
              return {
                host: url.hostname,
                port: parseInt(url.port) || 443
              };
            } catch {
              return null;
            }
          }
          
          async function testConfig(config) {
            const info = extractHost(config);
            if (!info) return { config, success: false, error: 'parse_failed' };
            
            const { host, port } = info;
            
            const tcpOk = await new Promise((resolve) => {
              const socket = net.connect(port, host);
              const timer = setTimeout(() => {
                socket.destroy();
                resolve(false);
              }, TIMEOUT);
              
              socket.on('connect', () => {
                clearTimeout(timer);
                socket.destroy();
                resolve(true);
              });
              
              socket.on('error', () => {
                clearTimeout(timer);
                resolve(false);
              });
            });
            
            if (!tcpOk) {
              return { config, success: false, error: 'tcp_timeout' };
            }
            
            const tlsOk = await new Promise((resolve) => {
              const socket = tls.connect({
                host,
                port,
                servername: host,
                rejectUnauthorized: false
              });
              
              const timer = setTimeout(() => {
                socket.destroy();
                resolve(false);
              }, TIMEOUT);
              
              socket.on('secureConnect', () => {
                clearTimeout(timer);
                socket.destroy();
                resolve(true);
              });
              
              socket.on('error', () => {
                clearTimeout(timer);
                resolve(false);
              });
            });
            
            return {
              config,
              success: tcpOk && tlsOk,
              error: tlsOk ? null : 'tls_failed',
              host,
              port
            };
          }
          
          async function runTests() {
            console.log(`üß™ Stage 1: Network connectivity test (${configs.length} configs)...`);
            
            const chunks = [];
            for (let i = 0; i < configs.length; i += MAX_PARALLEL) {
              chunks.push(configs.slice(i, i + MAX_PARALLEL));
            }
            
            for (const [idx, chunk] of chunks.entries()) {
              console.log(`  ‚Üí Batch ${idx + 1}/${chunks.length}`);
              const results_batch = await Promise.all(
                chunk.map(cfg => testConfig(cfg))
              );
              
              for (const result of results_batch) {
                if (result.success) {
                  results.working.push(result.config);
                } else {
                  results.failed.push(result);
                }
              }
            }
            
            fs.writeFileSync('tmp/network_passed.txt', results.working.join('\n'));
            fs.writeFileSync('logs/network_failed.json', JSON.stringify(results.failed, null, 2));
            
            console.log(`‚úÖ Network test complete: ${results.working.length} passed`);
            console.log(`‚ùå Network test failed: ${results.failed.length}`);
          }
          
          runTests();
          EOTEST
          
          node test.js

      - name: Simplified protocol validation
        run: |
          set -Eeuo pipefail
          
          echo "üöÄ Stage 2: Protocol validation..."
          
          if [[ ! -f tmp/network_passed.txt ]] || [[ ! -s tmp/network_passed.txt ]]; then
            echo "‚ö†Ô∏è  No configs passed network test"
            touch tmp/working_configs.txt
            exit 0
          fi
          
          # For now, we'll use network-passed configs directly
          # The network test already validates TCP and TLS connectivity
          # Proper Xray validation requires parsing each protocol's specific format
          
          cp tmp/network_passed.txt tmp/working_configs.txt
          
          TOTAL=$(wc -l < tmp/working_configs.txt)
          echo "‚úÖ Using ${TOTAL} network-validated configs"
          
          # Log a note about Xray validation being simplified
          cat > logs/xray_note.txt << 'EOF'
          NOTE: Full Xray protocol testing requires parsing and converting each 
          config URL into proper Xray JSON format. The current implementation 
          validates network connectivity (TCP + TLS handshake) which ensures 
          the servers are reachable, but full protocol compliance testing would 
          require additional parsing logic for each protocol type (vmess, vless, etc).
          EOF

      - name: Generate output files
        run: |
          set -Eeuo pipefail
          
          echo "üìù Generating final output files..."
          
          cp tmp/working_configs.txt "$OUTPUT_DIR/configs.txt"
          
          true > "$OUTPUT_DIR/configs_base64.txt"
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" ]] && continue
            echo "$line" | base64 -w0 >> "$OUTPUT_DIR/configs_base64.txt"
            echo >> "$OUTPUT_DIR/configs_base64.txt"
          done < "$OUTPUT_DIR/configs.txt"
          
          TOTAL=$(wc -l < tmp/configs_unique.txt)
          NETWORK_PASSED=$(wc -l < tmp/network_passed.txt 2>/dev/null || echo 0)
          FINAL_WORKING=$(wc -l < "$OUTPUT_DIR/configs.txt")
          NETWORK_FAILED=$((TOTAL - NETWORK_PASSED))
          
          cat > "$OUTPUT_DIR/stats.json" << EOF
          {
            "total_fetched": $TOTAL,
            "stage1_network_test": {
              "passed": $NETWORK_PASSED,
              "failed": $NETWORK_FAILED,
              "success_rate": "$(awk "BEGIN {if($TOTAL>0) printf \"%.2f\", ($NETWORK_PASSED/$TOTAL)*100; else print \"0.00\"}")%"
            },
            "stage2_validation": {
              "passed": $FINAL_WORKING,
              "method": "network_connectivity"
            },
            "final_working": $FINAL_WORKING,
            "overall_success_rate": "$(awk "BEGIN {if($TOTAL>0) printf \"%.2f\", ($FINAL_WORKING/$TOTAL)*100; else print \"0.00\"}")%",
            "updated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "testing_method": "tcp_tls_connectivity"
          }
          EOF
          
          echo "‚úÖ Generated configs.txt (${FINAL_WORKING} configs)"
          echo "‚úÖ Generated configs_base64.txt"
          echo "‚úÖ Generated stats.json"
          echo ""
          echo "üìä Summary:"
          echo "  Total fetched: $TOTAL"
          echo "  Network test passed: $NETWORK_PASSED"
          echo "  Final working: $FINAL_WORKING"
          echo "  Overall success: $(awk "BEGIN {if($TOTAL>0) printf \"%.2f\", ($FINAL_WORKING/$TOTAL)*100; else print \"0.00\"}")%"

      - name: Commit and push results
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add output/
          
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            git commit -m "Auto-update: $(wc -l < output/configs.txt) working configs [$(date -u +"%Y-%m-%d %H:%M UTC")]"
            
            max_retries=3
            retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              if git push; then
                echo "‚úÖ Changes committed and pushed"
                break
              else
                retry_count=$((retry_count + 1))
                if [ $retry_count -lt $max_retries ]; then
                  echo "‚ö†Ô∏è  Push failed, retrying ($retry_count/$max_retries)..."
                  sleep 2
                else
                  echo "‚ùå Push failed after $max_retries attempts"
                  exit 1
                fi
              fi
            done
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: v2ray-configs-${{ github.run_number }}
          path: |
            output/
            logs/
          retention-days: 30
