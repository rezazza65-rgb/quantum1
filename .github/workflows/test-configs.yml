name: QuantumRoute V6 - Supreme Intelligence (Iran Optimized) - FIXED V3

on:
  schedule:
    - cron: '0 */3 * * *'
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: write
  actions: read

concurrency:
  group: quantum-v6
  cancel-in-progress: true

env:
  OUTPUT_DIR: output
  TIMEOUT_MS: 8000
  MAX_PARALLEL: 40
  MIN_SCORE: 450
  STABILITY_ATTEMPTS: 7
  ENABLE_ML: true
  ENABLE_HONEYPOT_DETECTION: true
  ENABLE_IRAN_OPTIMIZATION: true
  ENABLE_ADVANCED_DPI_EVASION: true
  ENABLE_AUTO_RETRY: true
  ENABLE_FALLBACK_DNS: true
  ENABLE_LATENCY_OPTIMIZATION: true
  ENABLE_GEO_FILTERING: true

jobs:
  quantum-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 180

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: üì¶ Install All Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq curl netcat-openbsd openssl dnsutils whois traceroute mtr-tiny
          npm init -y
          # ‚ö†Ô∏è FIX: Use p-limit@3 (CommonJS compatible) instead of latest (ESM only)
          npm install p-limit@3 node-fetch@2 geoip-lite axios cheerio
          echo "‚úÖ Dependencies installed successfully"

      - name: üìÅ Create Directory Structure
        run: |
          mkdir -p "$OUTPUT_DIR" tmp logs cache history iran_specific backup
          
          if [[ -f output/history.json ]]; then
            cp output/history.json cache/history.json
            echo "‚úÖ ML history loaded"
          fi
          
          if [[ -f output/configs.txt ]]; then
            cp output/configs.txt backup/previous_configs.txt
            echo "‚úÖ Previous configs backed up"
          fi
          
          echo "‚úÖ Directories created"

      - name: üåê Fetch Configs from All Sources
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üåê QuantumRoute V6 - Supreme Intelligence Fetcher"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          > tmp/raw_all.txt
          > logs/fetch.log
          
          fetch_url() {
            local url="$1"
            local output="$2"
            local name="$3"
            
            if curl -fsSL --connect-timeout 30 --max-time 90 \
              -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" \
              -H "Accept: text/plain,*/*" \
              "$url" -o "$output" 2>/dev/null; then
              
              if [[ -s "$output" ]]; then
                if head -c 100 "$output" 2>/dev/null | grep -qE '^[A-Za-z0-9+/=]+$'; then
                  if base64 -d "$output" > "${output}.dec" 2>/dev/null; then
                    if [[ -s "${output}.dec" ]]; then
                      mv "${output}.dec" "$output"
                    fi
                  fi
                fi
                
                local lines=$(wc -l < "$output" 2>/dev/null || echo 0)
                echo "‚úÖ $name: $lines lines" | tee -a logs/fetch.log
                return 0
              fi
            fi
            
            echo "‚ùå $name: FAILED" >> logs/fetch.log
            return 1
          }
          
          echo "üì• Starting parallel downloads..."
          
          # PRIMARY SOURCES
          fetch_url "https://raw.githubusercontent.com/barry-far/V2ray-Configs/main/All_Configs_Sub.txt" "tmp/barry.txt" "barry-far" &
          fetch_url "https://raw.githubusercontent.com/Epodonios/v2ray-configs/main/All_Configs_Sub.txt" "tmp/epodonios.txt" "epodonios" &
          fetch_url "https://raw.githubusercontent.com/roosterkid/openproxylist/main/V2RAY_RAW.txt" "tmp/rooster_raw.txt" "roosterkid-raw" &
          fetch_url "https://raw.githubusercontent.com/roosterkid/openproxylist/main/V2RAY_BASE64.txt" "tmp/rooster_b64.txt" "roosterkid-b64" &
          fetch_url "https://raw.githubusercontent.com/itsyebekhe/PSG/main/subscriptions/xray/base64/mix" "tmp/yebekhe.txt" "yebekhe" &
          fetch_url "https://raw.githubusercontent.com/miladtahanian/V2RayCFGDumper/main/config.txt" "tmp/milad.txt" "milad" &
          fetch_url "https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all_extracted_configs.txt" "tmp/ebrasha.txt" "ebrasha" &
          fetch_url "https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/sub/sub_merge_base64.txt" "tmp/mahdi.txt" "mahdibland" &
          fetch_url "https://raw.githubusercontent.com/freefq/free/master/v2" "tmp/freefq.txt" "freefq" &
          fetch_url "https://raw.githubusercontent.com/Pawdroid/Free-servers/main/sub" "tmp/pawdroid.txt" "pawdroid" &
          fetch_url "https://raw.githubusercontent.com/aiboboxx/v2rayfree/main/v2" "tmp/aiboboxx.txt" "aiboboxx" &
          fetch_url "https://raw.githubusercontent.com/mfuu/v2ray/master/v2ray" "tmp/mfuu.txt" "mfuu" &
          fetch_url "https://raw.githubusercontent.com/peasoft/NoMoreWalls/master/list_raw.txt" "tmp/peasoft.txt" "peasoft" &
          fetch_url "https://raw.githubusercontent.com/ermaozi/get_subscribe/main/subscribe/v2ray.txt" "tmp/ermaozi.txt" "ermaozi" &
          
          wait
          echo "‚úÖ First batch completed"
          
          # SECONDARY SOURCES
          fetch_url "https://raw.githubusercontent.com/ShatakVPN/ConfigForge-V2Ray/main/configs/all.txt" "tmp/shatak.txt" "shatak" &
          fetch_url "https://raw.githubusercontent.com/ts-abc/v2ray-free-node/main/mergesub/merge_base64.txt" "tmp/tsabc.txt" "ts-abc" &
          fetch_url "https://raw.githubusercontent.com/Leon406/SubCrawler/master/sub/share/vless" "tmp/leon_vless.txt" "leon-vless" &
          fetch_url "https://raw.githubusercontent.com/Leon406/SubCrawler/master/sub/share/all3" "tmp/leon_all.txt" "leon-all" &
          fetch_url "https://raw.githubusercontent.com/tbbatbb/Proxy/master/dist/v2ray.config.txt" "tmp/tbbatbb.txt" "tbbatbb" &
          fetch_url "https://raw.githubusercontent.com/learnhard-cn/free_proxy_ss/main/v2ray/v2raysub" "tmp/learnhard.txt" "learnhard" &
          
          wait
          echo "‚úÖ Second batch completed"
          
          # COOK369 SOURCES
          for src in 85la cfmeme datiya jichangx nodefree oneclash yudou; do
            fetch_url "https://raw.githubusercontent.com/cook369/proxy-collect/main/dist/${src}/v2ray.txt" "tmp/cook_${src}.txt" "cook-${src}" &
          done
          
          wait
          echo "‚úÖ Cook369 sources completed"
          
          # FIRMFOX SOURCES
          for i in $(seq 1 10); do
            fetch_url "https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-${i}.txt" "tmp/firmfox_${i}.txt" "firmfox-${i}" &
          done
          wait
          
          for i in $(seq 11 20); do
            fetch_url "https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-${i}.txt" "tmp/firmfox_${i}.txt" "firmfox-${i}" &
          done
          wait
          
          for i in $(seq 21 30); do
            fetch_url "https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-${i}.txt" "tmp/firmfox_${i}.txt" "firmfox-${i}" &
          done
          wait
          
          for i in $(seq 31 38); do
            fetch_url "https://raw.githubusercontent.com/Firmfox/proxify/main/v2ray_configs/mixed/subscription-${i}.txt" "tmp/firmfox_${i}.txt" "firmfox-${i}" &
          done
          wait
          echo "‚úÖ Firmfox sources completed"
          
          # MERGE ALL FILES
          echo "üìä Merging all downloaded files..."
          
          for f in tmp/*.txt; do
            if [[ -f "$f" && -s "$f" ]]; then
              cat "$f" >> tmp/raw_all.txt 2>/dev/null || true
            fi
          done
          
          TOTAL_LINES=$(wc -l < tmp/raw_all.txt 2>/dev/null || echo 0)
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä Total lines fetched: $TOTAL_LINES"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          echo ""
          echo "üìã Fetch Summary:"
          cat logs/fetch.log | head -50
          
          if [[ $TOTAL_LINES -lt 50 ]]; then
            echo ""
            echo "‚ö†Ô∏è WARNING: Low config count ($TOTAL_LINES lines)"
            echo "üìù Attempting emergency fallback sources..."
            
            curl -fsSL --max-time 120 "https://raw.githubusercontent.com/barry-far/V2ray-Configs/main/Sub1.txt" >> tmp/raw_all.txt 2>/dev/null || true
            curl -fsSL --max-time 120 "https://raw.githubusercontent.com/barry-far/V2ray-Configs/main/Sub2.txt" >> tmp/raw_all.txt 2>/dev/null || true
            curl -fsSL --max-time 120 "https://raw.githubusercontent.com/barry-far/V2ray-Configs/main/Sub3.txt" >> tmp/raw_all.txt 2>/dev/null || true
            
            TOTAL_LINES=$(wc -l < tmp/raw_all.txt 2>/dev/null || echo 0)
            echo "üìä After fallback: $TOTAL_LINES lines"
          fi
          
          echo "‚úÖ Fetch phase completed"

      - name: üîç Parse & Deduplicate
        run: |
          echo "üîç Parsing and deduplicating configs..."
          
          grep -oE '(vmess|vless|trojan|ss|ssr|hysteria|hysteria2|hy2|tuic)://[^[:space:]"<>'"'"'\r\n]+' tmp/raw_all.txt 2>/dev/null | \
            sed 's/[[:space:]]*$//' | \
            sed 's/\r//g' | \
            sort -u > tmp/all_configs.txt || true
          
          EXTRACTED=$(wc -l < tmp/all_configs.txt 2>/dev/null || echo 0)
          echo "üìä Extracted proxy URLs: $EXTRACTED"
          
          > tmp/unique.txt
          declare -A SEEN
          
          while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || ${#line} -lt 15 ]] && continue
            
            clean=$(echo "$line" | tr -d '\r\n\t ' | sed 's/[[:space:]]//g')
            [[ -z "$clean" ]] && continue
            
            hash=$(echo -n "$clean" | md5sum | cut -d' ' -f1)
            
            if [[ -z "${SEEN[$hash]:-}" ]]; then
              SEEN[$hash]=1
              echo "$clean" >> tmp/unique.txt
            fi
          done < tmp/all_configs.txt
          
          UNIQUE_COUNT=$(wc -l < tmp/unique.txt 2>/dev/null || echo 0)
          echo "üìä Unique configs: $UNIQUE_COUNT"
          
          if [[ $UNIQUE_COUNT -lt 10 ]]; then
            echo "‚ö†Ô∏è WARNING: Very few unique configs ($UNIQUE_COUNT)"
          fi
          
          echo "‚úÖ Deduplication complete"

      - name: üß™ V6 Supreme Intelligence Tester
        run: |
          cat << 'TESTER_EOF' > tester.js
          const net = require('net');
          const fs = require('fs');
          const dns = require('dns');
          const pLimit = require('p-limit');
          
          // Configuration
          const TIMEOUT = parseInt(process.env.TIMEOUT_MS) || 8000;
          const PARALLEL = parseInt(process.env.MAX_PARALLEL) || 40;
          const MIN_SCORE = parseInt(process.env.MIN_SCORE) || 450;
          const STABILITY_ATTEMPTS = parseInt(process.env.STABILITY_ATTEMPTS) || 7;
          const ENABLE_ML = process.env.ENABLE_ML === 'true';
          const ENABLE_HONEYPOT = process.env.ENABLE_HONEYPOT_DETECTION === 'true';
          const ENABLE_IRAN_OPT = process.env.ENABLE_IRAN_OPTIMIZATION === 'true';
          const ENABLE_DPI_EVASION = process.env.ENABLE_ADVANCED_DPI_EVASION === 'true';
          const ENABLE_AUTO_RETRY = process.env.ENABLE_AUTO_RETRY === 'true';
          
          const limit = pLimit(PARALLEL);
          
          // Iran DPI Signatures
          const IRAN_DPI_SIGNATURES = {
            blockedPorts: [22, 1080, 3128, 8080, 8888, 9050, 10808],
            safePorts: [443, 2053, 2083, 2087, 2096, 8443, 80]
          };
          
          // CDN Ranges
          const CDN_RANGES = {
            cloudflare: ['103.21.244.', '103.22.200.', '103.31.4.', '104.16.', '104.17.', '104.18.', '104.19.', '104.20.', '104.21.', '104.22.', '104.23.', '104.24.', '104.25.', '104.26.', '104.27.', '108.162.', '131.0.72.', '141.101.', '162.158.', '162.159.', '172.64.', '172.65.', '172.66.', '172.67.', '173.245.', '188.114.', '190.93.', '197.234.', '198.41.'],
            fastly: ['151.101.', '199.232.', '185.31.', '146.75.'],
            amazon: ['52.', '54.', '13.', '18.', '34.', '35.'],
            google: ['35.', '34.', '142.250.', '172.217.']
          };
          
          // Protocol Weights
          const PROTOCOL_WEIGHTS = {
            vless: { base: 120, reality_bonus: 200, tls_bonus: 85, ws_bonus: 65, grpc_bonus: 70 },
            vmess: { base: 90, ws_bonus: 75, tls_bonus: 65, cdn_bonus: 55, h2_bonus: 60 },
            trojan: { base: 115, ws_bonus: 70, cdn_bonus: 60, grpc_bonus: 65 },
            hysteria: { base: 105, obfs_bonus: 50 },
            hysteria2: { base: 140, obfs_bonus: 55 },
            hy2: { base: 140, obfs_bonus: 55 },
            tuic: { base: 100, congestion_bonus: 45 },
            ss: { base: 75, plugin_bonus: 45 },
            shadowsocks: { base: 80, plugin_bonus: 50 }
          };
          
          // Port Scores
          const PORT_SCORES = {
            443: 110, 2053: 105, 2083: 105, 2087: 105, 2096: 105, 8443: 100,
            80: 80, 2052: 75, 2082: 75, 2086: 75, 2095: 75,
            8080: 45, 3128: 40, 1080: 25, default: 60
          };
          
          // ML History
          let mlHistory = [];
          let successfulHosts = new Map();
          let failedHosts = new Map();
          
          try {
            if (fs.existsSync('cache/history.json')) {
              mlHistory = JSON.parse(fs.readFileSync('cache/history.json', 'utf8'));
              console.log('üß† ML history loaded:', mlHistory.length, 'records');
              mlHistory.forEach(r => {
                if (r.success) successfulHosts.set(r.host, (successfulHosts.get(r.host) || 0) + 1);
                else failedHosts.set(r.host, (failedHosts.get(r.host) || 0) + 1);
              });
            }
          } catch (e) {
            console.log('‚ö†Ô∏è  No ML history found');
          }
          
          function detectCDN(ip) {
            if (!ip) return null;
            for (const [cdn, prefixes] of Object.entries(CDN_RANGES)) {
              if (prefixes.some(p => ip.startsWith(p))) return cdn;
            }
            return null;
          }
          
          function getCDNScore(cdn) {
            return { cloudflare: 90, fastly: 75, amazon: 65, google: 80 }[cdn] || 0;
          }
          
          function calculateDPIRisk(config) {
            let riskScore = 0;
            const risks = [];
            
            if (IRAN_DPI_SIGNATURES.blockedPorts.includes(config.port)) {
              riskScore += 50; risks.push('HIGH_RISK_PORT');
            } else if (IRAN_DPI_SIGNATURES.safePorts.includes(config.port)) {
              riskScore -= 30; risks.push('SAFE_PORT');
            }
            
            if (config.reality) { riskScore -= 60; risks.push('REALITY_PROTECTED'); }
            else if (['hysteria2', 'hy2'].includes(config.protocol)) { riskScore -= 40; risks.push('HYSTERIA2_PROTECTED'); }
            else if (config.protocol === 'vmess' && !config.tls && !config.ws) { riskScore += 45; risks.push('NO_ENCRYPTION'); }
            
            if (config.cdn) { riskScore -= getCDNScore(config.cdn) * 0.5; risks.push('CDN_' + config.cdn.toUpperCase()); }
            if (config.ws || config.grpc || config.h2) { riskScore -= 20; risks.push('TRANSPORT_OBFS'); }
            
            let risk = 'low';
            if (riskScore >= 70) risk = 'high';
            else if (riskScore >= 35) risk = 'medium';
            
            return { risk, score: Math.max(0, Math.min(100, riskScore)), reasons: risks };
          }
          
          function detectHoneypot(config, testResults) {
            let score = 0;
            const suspicious = [];
            
            if (testResults.latency && testResults.latency < 3) { suspicious.push('INSTANT_RESPONSE'); score += 35; }
            
            const patterns = ['test', 'monitor', 'honeypot', 'trap', 'fake'];
            if (config.host) {
              patterns.forEach(p => {
                if (config.host.toLowerCase().includes(p)) { suspicious.push('PATTERN_' + p.toUpperCase()); score += 40; }
              });
            }
            
            if ([31337, 12345, 54321, 6666, 1337].includes(config.port)) { suspicious.push('HONEYPOT_PORT'); score += 40; }
            
            return { isHoneypot: score >= 65, confidence: Math.min(100, score), reasons: suspicious };
          }
          
          function calculateMLConfidence(config) {
            if (!ENABLE_ML || mlHistory.length < 5) return 50;
            
            const similar = mlHistory.filter(h => h.protocol === config.protocol || h.host === config.host);
            if (similar.length === 0) return 50;
            
            const successRate = similar.filter(h => h.success).length / similar.length;
            return Math.min(100, Math.round(successRate * 70 + 30));
          }
          
          function parseConfig(url) {
            try {
              const parts = url.match(/^([^:]+):\/\/(.+)$/);
              if (!parts) return null;
              
              const protocol = parts[1].toLowerCase();
              const data = parts[2];
              const config = { protocol, raw: url };
              
              if (protocol === 'vmess') {
                try {
                  const json = JSON.parse(Buffer.from(data.split('#')[0], 'base64').toString());
                  config.host = json.add || json.host;
                  config.port = parseInt(json.port);
                  config.tls = json.tls === 'tls';
                  config.ws = json.net === 'ws';
                  config.grpc = json.net === 'grpc';
                  config.h2 = json.net === 'h2';
                } catch (e) { return null; }
              } else if (protocol === 'vless' || protocol === 'trojan') {
                const atIndex = data.indexOf('@');
                if (atIndex === -1) return null;
                const rest = data.substring(atIndex + 1);
                const qIndex = rest.indexOf('?');
                const hostPort = qIndex > -1 ? rest.substring(0, qIndex) : rest.split('#')[0];
                const colonIndex = hostPort.lastIndexOf(':');
                if (colonIndex === -1) return null;
                
                config.host = hostPort.substring(0, colonIndex);
                config.port = parseInt(hostPort.substring(colonIndex + 1).split('#')[0]);
                
                if (qIndex > -1) {
                  const params = rest.substring(qIndex + 1).split('#')[0];
                  const urlParams = new URLSearchParams(params);
                  config.security = urlParams.get('security');
                  config.tls = ['tls', 'reality'].includes(config.security);
                  config.reality = config.security === 'reality';
                  config.type = urlParams.get('type');
                  config.ws = config.type === 'ws';
                  config.grpc = config.type === 'grpc';
                  config.h2 = config.type === 'h2';
                }
              } else if (['hysteria', 'hysteria2', 'hy2'].includes(protocol)) {
                const atIndex = data.indexOf('@');
                if (atIndex === -1) return null;
                const rest = data.substring(atIndex + 1);
                const qIndex = rest.indexOf('?');
                const hostPort = qIndex > -1 ? rest.substring(0, qIndex) : rest.split('#')[0];
                const colonIndex = hostPort.lastIndexOf(':');
                if (colonIndex === -1) return null;
                config.host = hostPort.substring(0, colonIndex);
                config.port = parseInt(hostPort.substring(colonIndex + 1).split('#')[0]);
              } else if (['ss', 'shadowsocks'].includes(protocol)) {
                try {
                  const atIndex = data.indexOf('@');
                  if (atIndex > -1) {
                    const hostPort = data.substring(atIndex + 1).split('#')[0].split('?')[0];
                    const colonIndex = hostPort.lastIndexOf(':');
                    if (colonIndex > -1) {
                      config.host = hostPort.substring(0, colonIndex);
                      config.port = parseInt(hostPort.substring(colonIndex + 1));
                    }
                  } else {
                    const decoded = Buffer.from(data.split('#')[0], 'base64').toString();
                    const dAtIndex = decoded.indexOf('@');
                    if (dAtIndex > -1) {
                      const hostPort = decoded.substring(dAtIndex + 1);
                      const colonIndex = hostPort.lastIndexOf(':');
                      if (colonIndex > -1) {
                        config.host = hostPort.substring(0, colonIndex);
                        config.port = parseInt(hostPort.substring(colonIndex + 1));
                      }
                    }
                  }
                } catch (e) { return null; }
              } else if (protocol === 'tuic') {
                const atIndex = data.indexOf('@');
                if (atIndex === -1) return null;
                const rest = data.substring(atIndex + 1);
                const qIndex = rest.indexOf('?');
                const hostPort = qIndex > -1 ? rest.substring(0, qIndex) : rest.split('#')[0];
                const colonIndex = hostPort.lastIndexOf(':');
                if (colonIndex === -1) return null;
                config.host = hostPort.substring(0, colonIndex);
                config.port = parseInt(hostPort.substring(colonIndex + 1).split('#')[0]);
              }
              
              if (!config.host || !config.port || isNaN(config.port)) return null;
              if (config.port < 1 || config.port > 65535) return null;
              
              return config;
            } catch (e) { return null; }
          }
          
          function testConnection(host, port, timeout, retries) {
            timeout = timeout || TIMEOUT;
            retries = retries || 0;
            
            return new Promise(function(resolve) {
              const start = Date.now();
              const socket = net.createConnection({ host: host, port: port, timeout: timeout });
              
              socket.on('connect', function() {
                const latency = Date.now() - start;
                socket.destroy();
                resolve({ success: true, latency: latency, connected: true });
              });
              
              socket.on('error', function(err) {
                socket.destroy();
                if (ENABLE_AUTO_RETRY && retries < 2) {
                  setTimeout(function() {
                    testConnection(host, port, timeout, retries + 1).then(resolve);
                  }, 500);
                  return;
                }
                resolve({ success: false, latency: Date.now() - start, error: err.code });
              });
              
              socket.on('timeout', function() {
                socket.destroy();
                resolve({ success: false, latency: timeout, error: 'TIMEOUT' });
              });
            });
          }
          
          const dnsCache = new Map();
          function resolveHost(host) {
            return new Promise(function(resolve) {
              if (dnsCache.has(host)) { resolve(dnsCache.get(host)); return; }
              if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) { dnsCache.set(host, host); resolve(host); return; }
              
              dns.resolve4(host, function(err, addresses) {
                const result = err ? null : addresses[0];
                if (result) dnsCache.set(host, result);
                resolve(result);
              });
            });
          }
          
          function testStability(host, port) {
            return new Promise(async function(resolve) {
              const results = [];
              const latencies = [];
              
              for (let i = 0; i < STABILITY_ATTEMPTS; i++) {
                const result = await testConnection(host, port, TIMEOUT, 0);
                results.push(result);
                if (result.success) latencies.push(result.latency);
                await new Promise(function(r) { setTimeout(r, 100); });
              }
              
              const successful = results.filter(function(r) { return r.success; }).length;
              const avgLatency = latencies.length > 0 ? latencies.reduce(function(a, b) { return a + b; }, 0) / latencies.length : 0;
              
              let jitter = 0;
              if (latencies.length > 1) {
                const variance = latencies.reduce(function(sum, lat) { return sum + Math.pow(lat - avgLatency, 2); }, 0) / latencies.length;
                jitter = Math.sqrt(variance);
              }
              
              const stabilityScore = (successful / STABILITY_ATTEMPTS) * 100;
              
              resolve({
                stable: stabilityScore >= 60,
                veryStable: stabilityScore >= 85,
                ultraStable: stabilityScore === 100 && jitter < 20,
                score: stabilityScore,
                avgLatency: Math.round(avgLatency),
                jitter: Math.round(jitter),
                successful: successful
              });
            });
          }
          
          function calculateScore(config, testResults, stability, ip) {
            let score = 0;
            const breakdown = {};
            
            const pw = PROTOCOL_WEIGHTS[config.protocol];
            if (pw) {
              let ps = pw.base;
              if (config.reality && pw.reality_bonus) { ps += pw.reality_bonus; breakdown.reality = pw.reality_bonus; }
              if (config.tls && pw.tls_bonus) { ps += pw.tls_bonus; breakdown.tls = pw.tls_bonus; }
              if (config.ws && pw.ws_bonus) { ps += pw.ws_bonus; breakdown.ws = pw.ws_bonus; }
              if (config.grpc && pw.grpc_bonus) { ps += pw.grpc_bonus; breakdown.grpc = pw.grpc_bonus; }
              if (config.cdn && pw.cdn_bonus) { ps += pw.cdn_bonus; breakdown.cdn_bonus = pw.cdn_bonus; }
              score += ps;
              breakdown.protocol = ps;
            }
            
            const portScore = PORT_SCORES[config.port] || PORT_SCORES.default;
            score += portScore;
            breakdown.port = portScore;
            
            if (ip) {
              const cdn = detectCDN(ip);
              if (cdn) {
                const cdnScore = getCDNScore(cdn);
                score += cdnScore;
                breakdown.cdn_detected = cdnScore;
                config.cdn = cdn;
                if (cdn === 'cloudflare') { score += 50; breakdown.cloudflare_bonus = 50; }
              }
            }
            
            if (testResults.latency) {
              let ls;
              if (testResults.latency < 30) ls = 120;
              else if (testResults.latency < 50) ls = 100;
              else if (testResults.latency < 100) ls = 80;
              else if (testResults.latency < 150) ls = 60;
              else if (testResults.latency < 250) ls = 40;
              else ls = 20;
              score += ls;
              breakdown.latency = ls;
            }
            
            if (stability) {
              const ss = stability.score * 1.5;
              score += ss;
              breakdown.stability = Math.round(ss);
              
              if (stability.ultraStable) { score += 120; breakdown.ultra_stable = 120; }
              else if (stability.veryStable) { score += 80; breakdown.very_stable = 80; }
              
              if (stability.jitter < 20) { score += 40; breakdown.low_jitter = 40; }
              else if (stability.jitter > 100) { score -= 30; breakdown.high_jitter = -30; }
            }
            
            if (ENABLE_DPI_EVASION && ENABLE_IRAN_OPT) {
              const dpiRisk = calculateDPIRisk(config);
              let ds;
              if (dpiRisk.risk === 'low') ds = 90;
              else if (dpiRisk.risk === 'medium') ds = 40;
              else ds = -60;
              score += ds;
              breakdown.dpi_risk = ds;
            }
            
            if (ENABLE_ML) {
              const mlConf = calculateMLConfidence(config);
              const ms = (mlConf / 100) * 70;
              score += ms;
              breakdown.ml = Math.round(ms);
            }
            
            const hostSucc = successfulHosts.get(config.host) || 0;
            if (hostSucc >= 10) { score += 60; breakdown.proven_host = 60; }
            else if (hostSucc >= 5) { score += 30; breakdown.known_host = 30; }
            
            return { total: Math.round(score), breakdown: breakdown };
          }
          
          function assignGrade(score) {
            if (score >= 950) return 'S+';
            if (score >= 900) return 'S';
            if (score >= 800) return 'A+';
            if (score >= 700) return 'A';
            if (score >= 600) return 'B+';
            if (score >= 500) return 'B';
            if (score >= 400) return 'C';
            return 'D';
          }
          
          async function testConfig(url) {
            const config = parseConfig(url);
            if (!config) return null;
            
            const testResult = await testConnection(config.host, config.port, TIMEOUT, 0);
            if (!testResult.success) {
              failedHosts.set(config.host, (failedHosts.get(config.host) || 0) + 1);
              return null;
            }
            
            const ip = await resolveHost(config.host);
            if (ip) { config.cdn = detectCDN(ip); config.ip = ip; }
            
            const stability = await testStability(config.host, config.port);
            if (!stability.stable) {
              failedHosts.set(config.host, (failedHosts.get(config.host) || 0) + 1);
              return null;
            }
            
            const scoreResult = calculateScore(config, testResult, stability, ip);
            if (scoreResult.total < MIN_SCORE) return null;
            
            if (ENABLE_HONEYPOT) {
              const hp = detectHoneypot(config, testResult);
              if (hp.isHoneypot) {
                console.log('üè¥‚Äç‚ò†Ô∏è Honeypot:', config.host + ':' + config.port);
                return null;
              }
            }
            
            successfulHosts.set(config.host, (successfulHosts.get(config.host) || 0) + 1);
            
            const dpiRisk = ENABLE_IRAN_OPT ? calculateDPIRisk(config) : { risk: 'unknown', score: 0, reasons: [] };
            const mlConf = ENABLE_ML ? calculateMLConfidence(config) : 50;
            
            return {
              config: url,
              protocol: config.protocol,
              host: config.host,
              port: config.port,
              ip: config.ip,
              latency: testResult.latency,
              stability: stability.score,
              veryStable: stability.veryStable,
              ultraStable: stability.ultraStable,
              jitter: stability.jitter,
              score: scoreResult.total,
              score_breakdown: scoreResult.breakdown,
              grade: assignGrade(scoreResult.total),
              cdn: config.cdn || null,
              reality: config.reality || false,
              tls: config.tls || false,
              ws: config.ws || false,
              grpc: config.grpc || false,
              h2: config.h2 || false,
              dpi_risk: dpiRisk.risk,
              dpi_score: dpiRisk.score,
              dpi_reasons: dpiRisk.reasons,
              ml_confidence: mlConf,
              tested_at: Date.now()
            };
          }
          
          (async function() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üß™ QuantumRoute V6 - Supreme Intelligence Tester');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            let configs = [];
            try {
              configs = fs.readFileSync('tmp/unique.txt', 'utf8')
                .split('\n')
                .filter(function(l) { return l.trim().length > 10; });
            } catch (e) {
              console.log('‚ö†Ô∏è No configs to test');
              configs = [];
            }
            
            console.log('üìä Configs to test:', configs.length);
            
            if (configs.length === 0) {
              console.log('‚ö†Ô∏è No configs available. Creating empty output...');
              const emptyOutput = {
                timestamp: new Date().toISOString(),
                version: '6.0',
                summary: { total_tested: 0, working: 0, success_rate: '0%' },
                grades: { 'S+': 0, S: 0, 'A+': 0, A: 0, 'B+': 0, B: 0, C: 0, D: 0 },
                quality: { avg_latency: 0, avg_jitter: 0, avg_score: 0, avg_confidence: 0 },
                security: { honeypots_detected: 0, dpi_risk_high: 0, dpi_risk_medium: 0, dpi_risk_low: 0, cloudflare: 0, reality: 0 },
                stability: { ultra_stable: 0, very_stable: 0, stable_rate: '0%' },
                protocols: {},
                top_50: [],
                all_results: []
              };
              fs.writeFileSync('output/results.json', JSON.stringify(emptyOutput, null, 2));
              fs.writeFileSync('output/configs.txt', '');
              fs.writeFileSync('output/stats.json', JSON.stringify({ working: 0, grade_s_plus: 0, grade_s: 0, grade_a_plus: 0, grade_a: 0, avg_score: 0, iran_safe: 0, ultra_stable: 0, cloudflare: 0, reality: 0 }));
              process.exit(0);
            }
            
            const results = [];
            let tested = 0;
            let working = 0;
            const startTime = Date.now();
            
            const tasks = configs.map(function(c) {
              return limit(async function() {
                const r = await testConfig(c);
                tested++;
                if (r) { working++; results.push(r); }
                if (tested % 100 === 0) {
                  const pct = Math.round(tested / configs.length * 100);
                  console.log('üìä Progress:', pct + '% | Working:', working);
                }
              });
            });
            
            await Promise.all(tasks);
            
            const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log('‚úÖ Complete in', totalTime + 's | Working:', working + '/' + tested);
            
            results.sort(function(a, b) { return b.score - a.score; });
            
            const grades = { 'S+': 0, S: 0, 'A+': 0, A: 0, 'B+': 0, B: 0, C: 0, D: 0 };
            results.forEach(function(r) { grades[r.grade]++; });
            
            const avgLatency = results.length ? Math.round(results.reduce(function(s, r) { return s + r.latency; }, 0) / results.length) : 0;
            const avgScore = results.length ? Math.round(results.reduce(function(s, r) { return s + r.score; }, 0) / results.length) : 0;
            const avgConf = results.length ? Math.round(results.reduce(function(s, r) { return s + r.ml_confidence; }, 0) / results.length) : 0;
            const avgJitter = results.length ? Math.round(results.reduce(function(s, r) { return s + (r.jitter || 0); }, 0) / results.length) : 0;
            
            const protocols = {};
            results.forEach(function(r) { protocols[r.protocol] = (protocols[r.protocol] || 0) + 1; });
            
            const output = {
              timestamp: new Date().toISOString(),
              version: '6.0',
              iran_optimized: ENABLE_IRAN_OPT,
              summary: {
                total_tested: tested,
                working: working,
                success_rate: tested ? ((working / tested) * 100).toFixed(2) + '%' : '0%',
                testing_time: totalTime + 's'
              },
              grades: grades,
              quality: { avg_latency: avgLatency, avg_jitter: avgJitter, avg_score: avgScore, avg_confidence: avgConf },
              security: {
                honeypots_detected: 0,
                dpi_risk_high: results.filter(function(r) { return r.dpi_risk === 'high'; }).length,
                dpi_risk_medium: results.filter(function(r) { return r.dpi_risk === 'medium'; }).length,
                dpi_risk_low: results.filter(function(r) { return r.dpi_risk === 'low'; }).length,
                cloudflare: results.filter(function(r) { return r.cdn === 'cloudflare'; }).length,
                reality: results.filter(function(r) { return r.reality; }).length
              },
              stability: {
                ultra_stable: results.filter(function(r) { return r.ultraStable; }).length,
                very_stable: results.filter(function(r) { return r.veryStable; }).length,
                stable_rate: working ? ((results.filter(function(r) { return r.veryStable; }).length / working) * 100).toFixed(2) + '%' : '0%'
              },
              protocols: protocols,
              top_50: results.slice(0, 50),
              all_results: results
            };
            
            fs.writeFileSync('output/results.json', JSON.stringify(output, null, 2));
            fs.writeFileSync('output/configs.txt', results.map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/configs_base64.txt', Buffer.from(results.map(function(r) { return r.config; }).join('\n')).toString('base64'));
            fs.writeFileSync('output/best_200.txt', results.slice(0, 200).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/best_100.txt', results.slice(0, 100).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/best_50.txt', results.slice(0, 50).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/premium.txt', results.filter(function(r) { return ['S+', 'S', 'A+', 'A'].includes(r.grade); }).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/grade_s_plus.txt', results.filter(function(r) { return r.grade === 'S+'; }).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/grade_s.txt', results.filter(function(r) { return r.grade === 'S'; }).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/iran_safe.txt', results.filter(function(r) { return r.dpi_risk === 'low' && r.score >= 600; }).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/ultra_stable.txt', results.filter(function(r) { return r.ultraStable; }).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/cloudflare.txt', results.filter(function(r) { return r.cdn === 'cloudflare'; }).map(function(r) { return r.config; }).join('\n'));
            fs.writeFileSync('output/reality.txt', results.filter(function(r) { return r.reality; }).map(function(r) { return r.config; }).join('\n'));
            
            Object.keys(protocols).forEach(function(p) {
              fs.writeFileSync('output/protocol_' + p + '.txt', results.filter(function(r) { return r.protocol === p; }).map(function(r) { return r.config; }).join('\n'));
            });
            
            fs.writeFileSync('output/stats.json', JSON.stringify({
              working: working,
              grade_s_plus: grades['S+'],
              grade_s: grades.S,
              grade_a_plus: grades['A+'],
              grade_a: grades.A,
              avg_score: avgScore,
              iran_safe: results.filter(function(r) { return r.dpi_risk === 'low'; }).length,
              ultra_stable: results.filter(function(r) { return r.ultraStable; }).length,
              cloudflare: results.filter(function(r) { return r.cdn === 'cloudflare'; }).length,
              reality: results.filter(function(r) { return r.reality; }).length
            }));
            
            const newHistory = results.map(function(r) {
              return { protocol: r.protocol, host: r.host, port: r.port, cdn: r.cdn, latency: r.latency, success: true, score: r.score, timestamp: Date.now() };
            });
            fs.writeFileSync('output/history.json', JSON.stringify([].concat(mlHistory, newHistory).slice(-2000)));
            
            console.log('üìä Grades: S+:' + grades['S+'] + ' S:' + grades.S + ' A+:' + grades['A+'] + ' A:' + grades.A);
            process.exit(0);
          })();
          TESTER_EOF
          
          node tester.js

      - name: üìä Generate Dashboard
        run: |
          cat << 'DASHBOARD_EOF' > output/index.html
          <!DOCTYPE html>
          <html lang="fa" dir="rtl">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>QuantumRoute V6 üáÆüá∑</title>
            <style>
              :root{--bg:#0a0e27;--card:#1a2142;--gold:#ffd700;--green:#00ff88;--blue:#00d4ff;--red:#ff4444;--text:#fff;--text2:#b8c5d6}
              *{margin:0;padding:0;box-sizing:border-box}
              body{font-family:system-ui,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;padding:20px}
              .container{max-width:1400px;margin:0 auto}
              header{text-align:center;padding:40px;background:linear-gradient(135deg,#00a651,var(--card),#c8102e);border-radius:20px;margin-bottom:30px}
              h1{font-size:2.5em;background:linear-gradient(135deg,var(--gold),var(--blue));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
              .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:20px;margin-bottom:30px}
              .stat{background:var(--card);padding:25px;border-radius:15px;text-align:center}
              .stat-value{font-size:2.5em;font-weight:bold;margin:10px 0}
              .stat-label{color:var(--text2)}
              .section{background:var(--card);padding:30px;border-radius:15px;margin-bottom:30px}
              .section-title{font-size:1.8em;margin-bottom:20px;color:var(--gold)}
              .grades{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px}
              .grade{text-align:center;padding:20px;border-radius:10px;background:rgba(255,255,255,0.05)}
              .grade-badge{font-size:2em;font-weight:bold;padding:10px 20px;border-radius:10px;display:inline-block;margin-bottom:10px}
              .g-sp{background:linear-gradient(135deg,#ff6b6b,#ffd700);color:#000}
              .g-s{background:#ffd700;color:#000}
              .g-ap{background:linear-gradient(135deg,#00ff88,#00d4ff);color:#000}
              .g-a{background:#00d4ff;color:#000}
              .g-bp{background:#0099ff;color:#fff}
              .g-b{background:#0066ff;color:#fff}
              .g-c{background:#ff9500;color:#000}
              .btns{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin:30px 0}
              .btn{display:block;padding:15px;text-align:center;text-decoration:none;border-radius:10px;font-weight:bold;transition:transform 0.2s}
              .btn:hover{transform:translateY(-3px)}
              .btn-gold{background:var(--gold);color:#000}
              .btn-green{background:var(--green);color:#000}
              .btn-blue{background:var(--blue);color:#000}
              table{width:100%;border-collapse:collapse}
              th,td{padding:12px;text-align:right;border-bottom:1px solid rgba(255,255,255,0.1)}
              th{background:rgba(0,255,136,0.2);color:var(--green)}
              .tag{display:inline-block;padding:4px 10px;border-radius:5px;font-size:0.9em;font-weight:bold}
              .t-vless{background:#00ff88;color:#000}
              .t-vmess{background:#00d4ff;color:#000}
              .t-trojan{background:#ff9500;color:#000}
              .t-hy2{background:#ffd700;color:#000}
              .risk-low{background:#00ff88;color:#000}
              .risk-med{background:#ff9500;color:#000}
              .risk-high{background:#ff4444;color:#fff}
              footer{text-align:center;padding:30px;color:var(--text2)}
            </style>
          </head>
          <body>
            <div class="container">
              <header>
                <div style="font-size:3em">üáÆüá∑</div>
                <h1>QuantumRoute V6</h1>
                <p style="color:var(--text2);margin-top:10px">Supreme Intelligence Engine</p>
              </header>
              <div id="stats" class="stats"></div>
              <div class="section">
                <h2 class="section-title">üìä Grade Distribution</h2>
                <div id="grades" class="grades"></div>
              </div>
              <div class="btns">
                <a href="grade_s_plus.txt" class="btn btn-gold">üèÜ Grade S+</a>
                <a href="premium.txt" class="btn btn-green">‚≠ê Premium</a>
                <a href="iran_safe.txt" class="btn btn-green">üáÆüá∑ Iran Safe</a>
                <a href="ultra_stable.txt" class="btn btn-blue">üåü Ultra Stable</a>
                <a href="cloudflare.txt" class="btn btn-blue">‚òÅÔ∏è Cloudflare</a>
                <a href="reality.txt" class="btn btn-blue">üîê Reality</a>
                <a href="best_100.txt" class="btn btn-blue">üì• Top 100</a>
                <a href="configs.txt" class="btn btn-blue">üìÑ All</a>
              </div>
              <div class="section">
                <h2 class="section-title">üèÜ Top Configs</h2>
                <div style="overflow-x:auto">
                  <table><thead><tr><th>#</th><th>Grade</th><th>Protocol</th><th>Host</th><th>Port</th><th>Latency</th><th>Score</th><th>DPI Risk</th><th>CDN</th></tr></thead><tbody id="results"></tbody></table>
                </div>
              </div>
            </div>
            <footer>
              <p>üáÆüá∑ Optimized for Iran | Updated: <span id="ts">-</span></p>
            </footer>
            <script>
              fetch('results.json').then(function(r){return r.json();}).then(function(d){
                document.getElementById('stats').innerHTML=
                  '<div class="stat"><div class="stat-value" style="color:var(--blue)">'+d.summary.total_tested+'</div><div class="stat-label">Tested</div></div>'+
                  '<div class="stat"><div class="stat-value" style="color:var(--green)">'+d.summary.working+'</div><div class="stat-label">Working</div></div>'+
                  '<div class="stat"><div class="stat-value" style="color:var(--gold)">'+d.quality.avg_score+'</div><div class="stat-label">Avg Score</div></div>'+
                  '<div class="stat"><div class="stat-value" style="color:var(--blue)">'+d.quality.avg_latency+'ms</div><div class="stat-label">Avg Latency</div></div>';
                document.getElementById('grades').innerHTML=
                  '<div class="grade"><div class="grade-badge g-sp">S+</div><div>'+(d.grades['S+']||0)+'</div></div>'+
                  '<div class="grade"><div class="grade-badge g-s">S</div><div>'+(d.grades.S||0)+'</div></div>'+
                  '<div class="grade"><div class="grade-badge g-ap">A+</div><div>'+(d.grades['A+']||0)+'</div></div>'+
                  '<div class="grade"><div class="grade-badge g-a">A</div><div>'+(d.grades.A||0)+'</div></div>'+
                  '<div class="grade"><div class="grade-badge g-bp">B+</div><div>'+(d.grades['B+']||0)+'</div></div>'+
                  '<div class="grade"><div class="grade-badge g-b">B</div><div>'+(d.grades.B||0)+'</div></div>'+
                  '<div class="grade"><div class="grade-badge g-c">C</div><div>'+(d.grades.C||0)+'</div></div>';
                var tb=document.getElementById('results');
                (d.top_50||[]).slice(0,30).forEach(function(r,i){
                  var gc=r.grade.toLowerCase().replace('+','p');
                  var rc=r.dpi_risk==='high'?'high':r.dpi_risk==='medium'?'med':'low';
                  tb.innerHTML+='<tr><td>'+(i+1)+'</td><td><span class="grade-badge g-'+gc+'" style="font-size:1em;padding:3px 8px">'+r.grade+'</span></td><td><span class="tag t-'+r.protocol+'">'+r.protocol+'</span></td><td style="font-family:monospace;font-size:0.85em">'+r.host+'</td><td>'+r.port+'</td><td>'+r.latency+'ms</td><td><strong style="color:var(--gold)">'+r.score+'</strong></td><td><span class="tag risk-'+rc+'">'+(r.dpi_risk||'low')+'</span></td><td>'+(r.cdn||'-')+'</td></tr>';
                });
                document.getElementById('ts').textContent=new Date(d.timestamp).toLocaleString('fa-IR');
              });
            </script>
          </body>
          </html>
          DASHBOARD_EOF

      - name: üíæ Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add output/ || true
          
          if [[ -f output/stats.json ]]; then
            W=$(jq -r '.working // 0' output/stats.json)
            SP=$(jq -r '.grade_s_plus // 0' output/stats.json)
            S=$(jq -r '.grade_s // 0' output/stats.json)
            git commit -m "üöÄ V6: ${W} working | S+:${SP} S:${S}" || echo "No changes"
          else
            git commit -m "üöÄ V6 Update" || echo "No changes"
          fi
          
          git push origin main || git push --force origin main

      - name: üì¶ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: quantum-v6-${{ github.run_number }}
          path: output/
          retention-days: 30
        continue-on-error: true
